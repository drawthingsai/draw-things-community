// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: imageService.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum DeviceType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case phone // = 0
  case tablet // = 1
  case laptop // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .phone
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .phone
    case 1: self = .tablet
    case 2: self = .laptop
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .phone: return 0
    case .tablet: return 1
    case .laptop: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [DeviceType] = [
    .phone,
    .tablet,
    .laptop,
  ]

}

public struct EchoRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct EchoReply: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var message: String = String()

  public var files: [String] = []

  public var override: MetadataOverride {
    get {return _override ?? MetadataOverride()}
    set {_override = newValue}
  }
  /// Returns true if `override` has been explicitly set.
  public var hasOverride: Bool {return self._override != nil}
  /// Clears the value of `override`. Subsequent reads from it will return its default value.
  public mutating func clearOverride() {self._override = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _override: MetadataOverride? = nil
}

public struct FileListRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var files: [String] = []

  public var filesWithHash: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct FileExistenceResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var files: [String] = []

  public var existences: [Bool] = []

  public var hashes: [Data] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MetadataOverride: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var models: Data = Data()

  public var loras: Data = Data()

  public var controlNets: Data = Data()

  public var textualInversions: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// parameters in this Request is exactly same as generate function in ImageGenerator
public struct ImageGenerationRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Image data as sha256 content.
  public var image: Data {
    get {return _image ?? Data()}
    set {_image = newValue}
  }
  /// Returns true if `image` has been explicitly set.
  public var hasImage: Bool {return self._image != nil}
  /// Clears the value of `image`. Subsequent reads from it will return its default value.
  public mutating func clearImage() {self._image = nil}

  public var scaleFactor: Int32 = 0

  /// Optional  Mask data as sha256 content.
  public var mask: Data {
    get {return _mask ?? Data()}
    set {_mask = newValue}
  }
  /// Returns true if `mask` has been explicitly set.
  public var hasMask: Bool {return self._mask != nil}
  /// Clears the value of `mask`. Subsequent reads from it will return its default value.
  public mutating func clearMask() {self._mask = nil}

  /// List of hints
  public var hints: [HintProto] = []

  /// Optional prompt string
  public var prompt: String = String()

  /// Optional negative prompt string
  public var negativePrompt: String = String()

  /// Configuration data as bytes (FlatBuffer)
  public var configuration: Data = Data()

  /// Override the existing metadata on various Zoo objects.
  public var override: MetadataOverride {
    get {return _override ?? MetadataOverride()}
    set {_override = newValue}
  }
  /// Returns true if `override` has been explicitly set.
  public var hasOverride: Bool {return self._override != nil}
  /// Clears the value of `override`. Subsequent reads from it will return its default value.
  public mutating func clearOverride() {self._override = nil}

  /// Keywords send to the ImageGenerator, not useful for local generation.
  public var keywords: [String] = []

  /// The name of the client.
  public var user: String = String()

  /// The type of the device uses.
  public var device: DeviceType = .phone

  /// The image data as array of bytes. It is addressed by its sha256 content. This is modeled as content-addressable storage.
  public var contents: [Data] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _image: Data? = nil
  fileprivate var _mask: Data? = nil
  fileprivate var _override: MetadataOverride? = nil
}

public struct HintProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// hintType enum (key)
  public var hintType: String = String()

  /// Repeated list of tensors with associated float
  public var tensors: [TensorAndWeight] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Message to store each tensor and its associated float score
public struct TensorAndWeight: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Tensor data as sha256 to the content.
  public var tensor: Data = Data()

  /// Associated float score for the tensor
  public var weight: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ImageGenerationSignpostProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var signpost: ImageGenerationSignpostProto.OneOf_Signpost? = nil

  public var textEncoded: ImageGenerationSignpostProto.TextEncoded {
    get {
      if case .textEncoded(let v)? = signpost {return v}
      return ImageGenerationSignpostProto.TextEncoded()
    }
    set {signpost = .textEncoded(newValue)}
  }

  public var imageEncoded: ImageGenerationSignpostProto.ImageEncoded {
    get {
      if case .imageEncoded(let v)? = signpost {return v}
      return ImageGenerationSignpostProto.ImageEncoded()
    }
    set {signpost = .imageEncoded(newValue)}
  }

  public var sampling: ImageGenerationSignpostProto.Sampling {
    get {
      if case .sampling(let v)? = signpost {return v}
      return ImageGenerationSignpostProto.Sampling()
    }
    set {signpost = .sampling(newValue)}
  }

  public var imageDecoded: ImageGenerationSignpostProto.ImageDecoded {
    get {
      if case .imageDecoded(let v)? = signpost {return v}
      return ImageGenerationSignpostProto.ImageDecoded()
    }
    set {signpost = .imageDecoded(newValue)}
  }

  public var secondPassImageEncoded: ImageGenerationSignpostProto.SecondPassImageEncoded {
    get {
      if case .secondPassImageEncoded(let v)? = signpost {return v}
      return ImageGenerationSignpostProto.SecondPassImageEncoded()
    }
    set {signpost = .secondPassImageEncoded(newValue)}
  }

  public var secondPassSampling: ImageGenerationSignpostProto.SecondPassSampling {
    get {
      if case .secondPassSampling(let v)? = signpost {return v}
      return ImageGenerationSignpostProto.SecondPassSampling()
    }
    set {signpost = .secondPassSampling(newValue)}
  }

  public var secondPassImageDecoded: ImageGenerationSignpostProto.SecondPassImageDecoded {
    get {
      if case .secondPassImageDecoded(let v)? = signpost {return v}
      return ImageGenerationSignpostProto.SecondPassImageDecoded()
    }
    set {signpost = .secondPassImageDecoded(newValue)}
  }

  public var faceRestored: ImageGenerationSignpostProto.FaceRestored {
    get {
      if case .faceRestored(let v)? = signpost {return v}
      return ImageGenerationSignpostProto.FaceRestored()
    }
    set {signpost = .faceRestored(newValue)}
  }

  public var imageUpscaled: ImageGenerationSignpostProto.ImageUpscaled {
    get {
      if case .imageUpscaled(let v)? = signpost {return v}
      return ImageGenerationSignpostProto.ImageUpscaled()
    }
    set {signpost = .imageUpscaled(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Signpost: Equatable, Sendable {
    case textEncoded(ImageGenerationSignpostProto.TextEncoded)
    case imageEncoded(ImageGenerationSignpostProto.ImageEncoded)
    case sampling(ImageGenerationSignpostProto.Sampling)
    case imageDecoded(ImageGenerationSignpostProto.ImageDecoded)
    case secondPassImageEncoded(ImageGenerationSignpostProto.SecondPassImageEncoded)
    case secondPassSampling(ImageGenerationSignpostProto.SecondPassSampling)
    case secondPassImageDecoded(ImageGenerationSignpostProto.SecondPassImageDecoded)
    case faceRestored(ImageGenerationSignpostProto.FaceRestored)
    case imageUpscaled(ImageGenerationSignpostProto.ImageUpscaled)

  }

  public struct TextEncoded: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct ImageEncoded: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Sampling: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var step: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct ImageDecoded: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct SecondPassImageEncoded: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct SecondPassSampling: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var step: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct SecondPassImageDecoded: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct FaceRestored: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct ImageUpscaled: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct ImageGenerationResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Generated image data as bytes
  public var generatedImages: [Data] = []

  /// Single current signpost
  public var currentSignpost: ImageGenerationSignpostProto {
    get {return _currentSignpost ?? ImageGenerationSignpostProto()}
    set {_currentSignpost = newValue}
  }
  /// Returns true if `currentSignpost` has been explicitly set.
  public var hasCurrentSignpost: Bool {return self._currentSignpost != nil}
  /// Clears the value of `currentSignpost`. Subsequent reads from it will return its default value.
  public mutating func clearCurrentSignpost() {self._currentSignpost = nil}

  /// Collection of signposts
  public var signposts: [ImageGenerationSignpostProto] = []

  /// preview generating image data as bytes
  public var previewImage: Data {
    get {return _previewImage ?? Data()}
    set {_previewImage = newValue}
  }
  /// Returns true if `previewImage` has been explicitly set.
  public var hasPreviewImage: Bool {return self._previewImage != nil}
  /// Clears the value of `previewImage`. Subsequent reads from it will return its default value.
  public mutating func clearPreviewImage() {self._previewImage = nil}

  /// The scale factor of the image.
  public var scaleFactor: Int32 {
    get {return _scaleFactor ?? 0}
    set {_scaleFactor = newValue}
  }
  /// Returns true if `scaleFactor` has been explicitly set.
  public var hasScaleFactor: Bool {return self._scaleFactor != nil}
  /// Clears the value of `scaleFactor`. Subsequent reads from it will return its default value.
  public mutating func clearScaleFactor() {self._scaleFactor = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _currentSignpost: ImageGenerationSignpostProto? = nil
  fileprivate var _previewImage: Data? = nil
  fileprivate var _scaleFactor: Int32? = nil
}

public struct FileChunk: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var content: Data = Data()

  public var filename: String = String()

  public var offset: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct InitUploadRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the file to be uploaded.
  public var filename: String = String()

  /// SHA-256 hash of the file.
  public var sha256: Data = Data()

  /// Total size of the file in bytes.
  public var totalSize: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct UploadResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chunkUploadSuccess: Bool = false

  public var receivedOffset: Int64 = 0

  public var message: String = String()

  public var filename: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Union type for either an InitUploadRequest or FileChunk.
public struct FileUploadRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var request: FileUploadRequest.OneOf_Request? = nil

  /// Initial upload request to sync SHA and filename.
  public var initRequest: InitUploadRequest {
    get {
      if case .initRequest(let v)? = request {return v}
      return InitUploadRequest()
    }
    set {request = .initRequest(newValue)}
  }

  /// File chunk data.
  public var chunk: FileChunk {
    get {
      if case .chunk(let v)? = request {return v}
      return FileChunk()
    }
    set {request = .chunk(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Request: Equatable, Sendable {
    /// Initial upload request to sync SHA and filename.
    case initRequest(InitUploadRequest)
    /// File chunk data.
    case chunk(FileChunk)

  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension DeviceType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PHONE"),
    1: .same(proto: "TABLET"),
    2: .same(proto: "LAPTOP"),
  ]
}

extension EchoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "EchoRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EchoRequest, rhs: EchoRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EchoReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "EchoReply"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
    2: .same(proto: "files"),
    3: .same(proto: "override"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.files) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._override) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    if !self.files.isEmpty {
      try visitor.visitRepeatedStringField(value: self.files, fieldNumber: 2)
    }
    try { if let v = self._override {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EchoReply, rhs: EchoReply) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.files != rhs.files {return false}
    if lhs._override != rhs._override {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FileListRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "FileListRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "files"),
    2: .same(proto: "filesWithHash"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.files) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.filesWithHash) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.files.isEmpty {
      try visitor.visitRepeatedStringField(value: self.files, fieldNumber: 1)
    }
    if !self.filesWithHash.isEmpty {
      try visitor.visitRepeatedStringField(value: self.filesWithHash, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FileListRequest, rhs: FileListRequest) -> Bool {
    if lhs.files != rhs.files {return false}
    if lhs.filesWithHash != rhs.filesWithHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FileExistenceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "FileExistenceResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "files"),
    2: .same(proto: "existences"),
    3: .same(proto: "hashes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.files) }()
      case 2: try { try decoder.decodeRepeatedBoolField(value: &self.existences) }()
      case 3: try { try decoder.decodeRepeatedBytesField(value: &self.hashes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.files.isEmpty {
      try visitor.visitRepeatedStringField(value: self.files, fieldNumber: 1)
    }
    if !self.existences.isEmpty {
      try visitor.visitPackedBoolField(value: self.existences, fieldNumber: 2)
    }
    if !self.hashes.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.hashes, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FileExistenceResponse, rhs: FileExistenceResponse) -> Bool {
    if lhs.files != rhs.files {return false}
    if lhs.existences != rhs.existences {return false}
    if lhs.hashes != rhs.hashes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MetadataOverride: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "MetadataOverride"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "models"),
    2: .same(proto: "loras"),
    3: .same(proto: "controlNets"),
    4: .same(proto: "textualInversions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.models) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.loras) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.controlNets) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.textualInversions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.models.isEmpty {
      try visitor.visitSingularBytesField(value: self.models, fieldNumber: 1)
    }
    if !self.loras.isEmpty {
      try visitor.visitSingularBytesField(value: self.loras, fieldNumber: 2)
    }
    if !self.controlNets.isEmpty {
      try visitor.visitSingularBytesField(value: self.controlNets, fieldNumber: 3)
    }
    if !self.textualInversions.isEmpty {
      try visitor.visitSingularBytesField(value: self.textualInversions, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MetadataOverride, rhs: MetadataOverride) -> Bool {
    if lhs.models != rhs.models {return false}
    if lhs.loras != rhs.loras {return false}
    if lhs.controlNets != rhs.controlNets {return false}
    if lhs.textualInversions != rhs.textualInversions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ImageGenerationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ImageGenerationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "image"),
    2: .same(proto: "scaleFactor"),
    3: .same(proto: "mask"),
    4: .same(proto: "hints"),
    5: .same(proto: "prompt"),
    6: .same(proto: "negativePrompt"),
    7: .same(proto: "configuration"),
    8: .same(proto: "override"),
    9: .same(proto: "keywords"),
    10: .same(proto: "user"),
    11: .same(proto: "device"),
    12: .same(proto: "contents"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._image) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.scaleFactor) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._mask) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.hints) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.prompt) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.negativePrompt) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.configuration) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._override) }()
      case 9: try { try decoder.decodeRepeatedStringField(value: &self.keywords) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.user) }()
      case 11: try { try decoder.decodeSingularEnumField(value: &self.device) }()
      case 12: try { try decoder.decodeRepeatedBytesField(value: &self.contents) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._image {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    if self.scaleFactor != 0 {
      try visitor.visitSingularInt32Field(value: self.scaleFactor, fieldNumber: 2)
    }
    try { if let v = self._mask {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    if !self.hints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.hints, fieldNumber: 4)
    }
    if !self.prompt.isEmpty {
      try visitor.visitSingularStringField(value: self.prompt, fieldNumber: 5)
    }
    if !self.negativePrompt.isEmpty {
      try visitor.visitSingularStringField(value: self.negativePrompt, fieldNumber: 6)
    }
    if !self.configuration.isEmpty {
      try visitor.visitSingularBytesField(value: self.configuration, fieldNumber: 7)
    }
    try { if let v = self._override {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    if !self.keywords.isEmpty {
      try visitor.visitRepeatedStringField(value: self.keywords, fieldNumber: 9)
    }
    if !self.user.isEmpty {
      try visitor.visitSingularStringField(value: self.user, fieldNumber: 10)
    }
    if self.device != .phone {
      try visitor.visitSingularEnumField(value: self.device, fieldNumber: 11)
    }
    if !self.contents.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.contents, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ImageGenerationRequest, rhs: ImageGenerationRequest) -> Bool {
    if lhs._image != rhs._image {return false}
    if lhs.scaleFactor != rhs.scaleFactor {return false}
    if lhs._mask != rhs._mask {return false}
    if lhs.hints != rhs.hints {return false}
    if lhs.prompt != rhs.prompt {return false}
    if lhs.negativePrompt != rhs.negativePrompt {return false}
    if lhs.configuration != rhs.configuration {return false}
    if lhs._override != rhs._override {return false}
    if lhs.keywords != rhs.keywords {return false}
    if lhs.user != rhs.user {return false}
    if lhs.device != rhs.device {return false}
    if lhs.contents != rhs.contents {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HintProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "HintProto"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hintType"),
    2: .same(proto: "tensors"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.hintType) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.tensors) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hintType.isEmpty {
      try visitor.visitSingularStringField(value: self.hintType, fieldNumber: 1)
    }
    if !self.tensors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tensors, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: HintProto, rhs: HintProto) -> Bool {
    if lhs.hintType != rhs.hintType {return false}
    if lhs.tensors != rhs.tensors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TensorAndWeight: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "TensorAndWeight"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tensor"),
    2: .same(proto: "weight"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.tensor) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.weight) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tensor.isEmpty {
      try visitor.visitSingularBytesField(value: self.tensor, fieldNumber: 1)
    }
    if self.weight.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.weight, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TensorAndWeight, rhs: TensorAndWeight) -> Bool {
    if lhs.tensor != rhs.tensor {return false}
    if lhs.weight != rhs.weight {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ImageGenerationSignpostProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ImageGenerationSignpostProto"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "textEncoded"),
    2: .same(proto: "imageEncoded"),
    3: .same(proto: "sampling"),
    4: .same(proto: "imageDecoded"),
    5: .same(proto: "secondPassImageEncoded"),
    6: .same(proto: "secondPassSampling"),
    7: .same(proto: "secondPassImageDecoded"),
    8: .same(proto: "faceRestored"),
    9: .same(proto: "imageUpscaled"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: ImageGenerationSignpostProto.TextEncoded?
        var hadOneofValue = false
        if let current = self.signpost {
          hadOneofValue = true
          if case .textEncoded(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.signpost = .textEncoded(v)
        }
      }()
      case 2: try {
        var v: ImageGenerationSignpostProto.ImageEncoded?
        var hadOneofValue = false
        if let current = self.signpost {
          hadOneofValue = true
          if case .imageEncoded(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.signpost = .imageEncoded(v)
        }
      }()
      case 3: try {
        var v: ImageGenerationSignpostProto.Sampling?
        var hadOneofValue = false
        if let current = self.signpost {
          hadOneofValue = true
          if case .sampling(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.signpost = .sampling(v)
        }
      }()
      case 4: try {
        var v: ImageGenerationSignpostProto.ImageDecoded?
        var hadOneofValue = false
        if let current = self.signpost {
          hadOneofValue = true
          if case .imageDecoded(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.signpost = .imageDecoded(v)
        }
      }()
      case 5: try {
        var v: ImageGenerationSignpostProto.SecondPassImageEncoded?
        var hadOneofValue = false
        if let current = self.signpost {
          hadOneofValue = true
          if case .secondPassImageEncoded(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.signpost = .secondPassImageEncoded(v)
        }
      }()
      case 6: try {
        var v: ImageGenerationSignpostProto.SecondPassSampling?
        var hadOneofValue = false
        if let current = self.signpost {
          hadOneofValue = true
          if case .secondPassSampling(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.signpost = .secondPassSampling(v)
        }
      }()
      case 7: try {
        var v: ImageGenerationSignpostProto.SecondPassImageDecoded?
        var hadOneofValue = false
        if let current = self.signpost {
          hadOneofValue = true
          if case .secondPassImageDecoded(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.signpost = .secondPassImageDecoded(v)
        }
      }()
      case 8: try {
        var v: ImageGenerationSignpostProto.FaceRestored?
        var hadOneofValue = false
        if let current = self.signpost {
          hadOneofValue = true
          if case .faceRestored(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.signpost = .faceRestored(v)
        }
      }()
      case 9: try {
        var v: ImageGenerationSignpostProto.ImageUpscaled?
        var hadOneofValue = false
        if let current = self.signpost {
          hadOneofValue = true
          if case .imageUpscaled(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.signpost = .imageUpscaled(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.signpost {
    case .textEncoded?: try {
      guard case .textEncoded(let v)? = self.signpost else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .imageEncoded?: try {
      guard case .imageEncoded(let v)? = self.signpost else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .sampling?: try {
      guard case .sampling(let v)? = self.signpost else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .imageDecoded?: try {
      guard case .imageDecoded(let v)? = self.signpost else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .secondPassImageEncoded?: try {
      guard case .secondPassImageEncoded(let v)? = self.signpost else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .secondPassSampling?: try {
      guard case .secondPassSampling(let v)? = self.signpost else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .secondPassImageDecoded?: try {
      guard case .secondPassImageDecoded(let v)? = self.signpost else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .faceRestored?: try {
      guard case .faceRestored(let v)? = self.signpost else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .imageUpscaled?: try {
      guard case .imageUpscaled(let v)? = self.signpost else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ImageGenerationSignpostProto, rhs: ImageGenerationSignpostProto) -> Bool {
    if lhs.signpost != rhs.signpost {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ImageGenerationSignpostProto.TextEncoded: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ImageGenerationSignpostProto.protoMessageName + ".TextEncoded"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ImageGenerationSignpostProto.TextEncoded, rhs: ImageGenerationSignpostProto.TextEncoded) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ImageGenerationSignpostProto.ImageEncoded: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ImageGenerationSignpostProto.protoMessageName + ".ImageEncoded"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ImageGenerationSignpostProto.ImageEncoded, rhs: ImageGenerationSignpostProto.ImageEncoded) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ImageGenerationSignpostProto.Sampling: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ImageGenerationSignpostProto.protoMessageName + ".Sampling"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "step"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.step) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.step != 0 {
      try visitor.visitSingularInt32Field(value: self.step, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ImageGenerationSignpostProto.Sampling, rhs: ImageGenerationSignpostProto.Sampling) -> Bool {
    if lhs.step != rhs.step {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ImageGenerationSignpostProto.ImageDecoded: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ImageGenerationSignpostProto.protoMessageName + ".ImageDecoded"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ImageGenerationSignpostProto.ImageDecoded, rhs: ImageGenerationSignpostProto.ImageDecoded) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ImageGenerationSignpostProto.SecondPassImageEncoded: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ImageGenerationSignpostProto.protoMessageName + ".SecondPassImageEncoded"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ImageGenerationSignpostProto.SecondPassImageEncoded, rhs: ImageGenerationSignpostProto.SecondPassImageEncoded) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ImageGenerationSignpostProto.SecondPassSampling: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ImageGenerationSignpostProto.protoMessageName + ".SecondPassSampling"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "step"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.step) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.step != 0 {
      try visitor.visitSingularInt32Field(value: self.step, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ImageGenerationSignpostProto.SecondPassSampling, rhs: ImageGenerationSignpostProto.SecondPassSampling) -> Bool {
    if lhs.step != rhs.step {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ImageGenerationSignpostProto.SecondPassImageDecoded: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ImageGenerationSignpostProto.protoMessageName + ".SecondPassImageDecoded"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ImageGenerationSignpostProto.SecondPassImageDecoded, rhs: ImageGenerationSignpostProto.SecondPassImageDecoded) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ImageGenerationSignpostProto.FaceRestored: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ImageGenerationSignpostProto.protoMessageName + ".FaceRestored"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ImageGenerationSignpostProto.FaceRestored, rhs: ImageGenerationSignpostProto.FaceRestored) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ImageGenerationSignpostProto.ImageUpscaled: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ImageGenerationSignpostProto.protoMessageName + ".ImageUpscaled"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ImageGenerationSignpostProto.ImageUpscaled, rhs: ImageGenerationSignpostProto.ImageUpscaled) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ImageGenerationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ImageGenerationResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "generatedImages"),
    2: .same(proto: "currentSignpost"),
    3: .same(proto: "signposts"),
    4: .same(proto: "previewImage"),
    5: .same(proto: "scaleFactor"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBytesField(value: &self.generatedImages) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._currentSignpost) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.signposts) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self._previewImage) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self._scaleFactor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.generatedImages.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.generatedImages, fieldNumber: 1)
    }
    try { if let v = self._currentSignpost {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.signposts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.signposts, fieldNumber: 3)
    }
    try { if let v = self._previewImage {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._scaleFactor {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ImageGenerationResponse, rhs: ImageGenerationResponse) -> Bool {
    if lhs.generatedImages != rhs.generatedImages {return false}
    if lhs._currentSignpost != rhs._currentSignpost {return false}
    if lhs.signposts != rhs.signposts {return false}
    if lhs._previewImage != rhs._previewImage {return false}
    if lhs._scaleFactor != rhs._scaleFactor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FileChunk: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "FileChunk"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "content"),
    2: .same(proto: "filename"),
    3: .same(proto: "offset"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.content) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.filename) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.content.isEmpty {
      try visitor.visitSingularBytesField(value: self.content, fieldNumber: 1)
    }
    if !self.filename.isEmpty {
      try visitor.visitSingularStringField(value: self.filename, fieldNumber: 2)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FileChunk, rhs: FileChunk) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.filename != rhs.filename {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension InitUploadRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "InitUploadRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "filename"),
    2: .same(proto: "sha256"),
    3: .same(proto: "totalSize"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.filename) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.sha256) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.totalSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.filename.isEmpty {
      try visitor.visitSingularStringField(value: self.filename, fieldNumber: 1)
    }
    if !self.sha256.isEmpty {
      try visitor.visitSingularBytesField(value: self.sha256, fieldNumber: 2)
    }
    if self.totalSize != 0 {
      try visitor.visitSingularInt64Field(value: self.totalSize, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: InitUploadRequest, rhs: InitUploadRequest) -> Bool {
    if lhs.filename != rhs.filename {return false}
    if lhs.sha256 != rhs.sha256 {return false}
    if lhs.totalSize != rhs.totalSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UploadResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UploadResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chunkUploadSuccess"),
    2: .same(proto: "receivedOffset"),
    3: .same(proto: "message"),
    4: .same(proto: "filename"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.chunkUploadSuccess) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.receivedOffset) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.filename) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.chunkUploadSuccess != false {
      try visitor.visitSingularBoolField(value: self.chunkUploadSuccess, fieldNumber: 1)
    }
    if self.receivedOffset != 0 {
      try visitor.visitSingularInt64Field(value: self.receivedOffset, fieldNumber: 2)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 3)
    }
    if !self.filename.isEmpty {
      try visitor.visitSingularStringField(value: self.filename, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UploadResponse, rhs: UploadResponse) -> Bool {
    if lhs.chunkUploadSuccess != rhs.chunkUploadSuccess {return false}
    if lhs.receivedOffset != rhs.receivedOffset {return false}
    if lhs.message != rhs.message {return false}
    if lhs.filename != rhs.filename {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FileUploadRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "FileUploadRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "initRequest"),
    2: .same(proto: "chunk"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: InitUploadRequest?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .initRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .initRequest(v)
        }
      }()
      case 2: try {
        var v: FileChunk?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .chunk(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .chunk(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.request {
    case .initRequest?: try {
      guard case .initRequest(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .chunk?: try {
      guard case .chunk(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FileUploadRequest, rhs: FileUploadRequest) -> Bool {
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
