// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: imageService.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum DeviceType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case phone // = 0
  case tablet // = 1
  case laptop // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .phone
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .phone
    case 1: self = .tablet
    case 2: self = .laptop
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .phone: return 0
    case .tablet: return 1
    case .laptop: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [DeviceType] = [
    .phone,
    .tablet,
    .laptop,
  ]

}

public enum ChunkState: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case lastChunk // = 0
  case moreChunks // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .lastChunk
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .lastChunk
    case 1: self = .moreChunks
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .lastChunk: return 0
    case .moreChunks: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [ChunkState] = [
    .lastChunk,
    .moreChunks,
  ]

}

public struct EchoRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  /// The secret use to authenticate if needed.
  public var sharedSecret: String {
    get {return _sharedSecret ?? String()}
    set {_sharedSecret = newValue}
  }
  /// Returns true if `sharedSecret` has been explicitly set.
  public var hasSharedSecret: Bool {return self._sharedSecret != nil}
  /// Clears the value of `sharedSecret`. Subsequent reads from it will return its default value.
  public mutating func clearSharedSecret() {self._sharedSecret = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _sharedSecret: String? = nil
}

public struct ComputeUnitThreshold: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var community: Double = 0

  public var plus: Double = 0

  public var expireAt: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct EchoReply: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var message: String = String()

  public var files: [String] = []

  public var override: MetadataOverride {
    get {return _override ?? MetadataOverride()}
    set {_override = newValue}
  }
  /// Returns true if `override` has been explicitly set.
  public var hasOverride: Bool {return self._override != nil}
  /// Clears the value of `override`. Subsequent reads from it will return its default value.
  public mutating func clearOverride() {self._override = nil}

  /// If this is true, sharedSecret is required.
  public var sharedSecretMissing: Bool = false

  /// The thresholds currently imposed by the server.
  public var thresholds: ComputeUnitThreshold {
    get {return _thresholds ?? ComputeUnitThreshold()}
    set {_thresholds = newValue}
  }
  /// Returns true if `thresholds` has been explicitly set.
  public var hasThresholds: Bool {return self._thresholds != nil}
  /// Clears the value of `thresholds`. Subsequent reads from it will return its default value.
  public mutating func clearThresholds() {self._thresholds = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _override: MetadataOverride? = nil
  fileprivate var _thresholds: ComputeUnitThreshold? = nil
}

public struct FileListRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var files: [String] = []

  public var filesWithHash: [String] = []

  /// The secret use to authenticate if needed.
  public var sharedSecret: String {
    get {return _sharedSecret ?? String()}
    set {_sharedSecret = newValue}
  }
  /// Returns true if `sharedSecret` has been explicitly set.
  public var hasSharedSecret: Bool {return self._sharedSecret != nil}
  /// Clears the value of `sharedSecret`. Subsequent reads from it will return its default value.
  public mutating func clearSharedSecret() {self._sharedSecret = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _sharedSecret: String? = nil
}

public struct FileExistenceResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var files: [String] = []

  public var existences: [Bool] = []

  public var hashes: [Data] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MetadataOverride: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var models: Data = Data()

  public var loras: Data = Data()

  public var controlNets: Data = Data()

  public var textualInversions: Data = Data()

  public var upscalers: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// parameters in this Request is exactly same as generate function in ImageGenerator
public struct ImageGenerationRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Image data as sha256 content.
  public var image: Data {
    get {return _storage._image ?? Data()}
    set {_uniqueStorage()._image = newValue}
  }
  /// Returns true if `image` has been explicitly set.
  public var hasImage: Bool {return _storage._image != nil}
  /// Clears the value of `image`. Subsequent reads from it will return its default value.
  public mutating func clearImage() {_uniqueStorage()._image = nil}

  public var scaleFactor: Int32 {
    get {return _storage._scaleFactor}
    set {_uniqueStorage()._scaleFactor = newValue}
  }

  /// Optional  Mask data as sha256 content.
  public var mask: Data {
    get {return _storage._mask ?? Data()}
    set {_uniqueStorage()._mask = newValue}
  }
  /// Returns true if `mask` has been explicitly set.
  public var hasMask: Bool {return _storage._mask != nil}
  /// Clears the value of `mask`. Subsequent reads from it will return its default value.
  public mutating func clearMask() {_uniqueStorage()._mask = nil}

  /// List of hints
  public var hints: [HintProto] {
    get {return _storage._hints}
    set {_uniqueStorage()._hints = newValue}
  }

  /// Optional prompt string
  public var prompt: String {
    get {return _storage._prompt}
    set {_uniqueStorage()._prompt = newValue}
  }

  /// Optional negative prompt string
  public var negativePrompt: String {
    get {return _storage._negativePrompt}
    set {_uniqueStorage()._negativePrompt = newValue}
  }

  /// Configuration data as bytes (FlatBuffer)
  public var configuration: Data {
    get {return _storage._configuration}
    set {_uniqueStorage()._configuration = newValue}
  }

  /// Override the existing metadata on various Zoo objects.
  public var override: MetadataOverride {
    get {return _storage._override ?? MetadataOverride()}
    set {_uniqueStorage()._override = newValue}
  }
  /// Returns true if `override` has been explicitly set.
  public var hasOverride: Bool {return _storage._override != nil}
  /// Clears the value of `override`. Subsequent reads from it will return its default value.
  public mutating func clearOverride() {_uniqueStorage()._override = nil}

  /// Keywords send to the ImageGenerator, not useful for local generation.
  public var keywords: [String] {
    get {return _storage._keywords}
    set {_uniqueStorage()._keywords = newValue}
  }

  /// The name of the client.
  public var user: String {
    get {return _storage._user}
    set {_uniqueStorage()._user = newValue}
  }

  /// The type of the device uses.
  public var device: DeviceType {
    get {return _storage._device}
    set {_uniqueStorage()._device = newValue}
  }

  /// The image data as array of bytes. It is addressed by its sha256 content. This is modeled as content-addressable storage.
  public var contents: [Data] {
    get {return _storage._contents}
    set {_uniqueStorage()._contents = newValue}
  }

  /// The secret use to authenticate if needed.
  public var sharedSecret: String {
    get {return _storage._sharedSecret ?? String()}
    set {_uniqueStorage()._sharedSecret = newValue}
  }
  /// Returns true if `sharedSecret` has been explicitly set.
  public var hasSharedSecret: Bool {return _storage._sharedSecret != nil}
  /// Clears the value of `sharedSecret`. Subsequent reads from it will return its default value.
  public mutating func clearSharedSecret() {_uniqueStorage()._sharedSecret = nil}

  /// Whether we can accept chunked response.
  public var chunked: Bool {
    get {return _storage._chunked}
    set {_uniqueStorage()._chunked = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct HintProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// hintType enum (key)
  public var hintType: String = String()

  /// Repeated list of tensors with associated float
  public var tensors: [TensorAndWeight] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Message to store each tensor and its associated float score
public struct TensorAndWeight: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Tensor data as sha256 to the content.
  public var tensor: Data = Data()

  /// Associated float score for the tensor
  public var weight: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ImageGenerationSignpostProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var signpost: ImageGenerationSignpostProto.OneOf_Signpost? = nil

  public var textEncoded: ImageGenerationSignpostProto.TextEncoded {
    get {
      if case .textEncoded(let v)? = signpost {return v}
      return ImageGenerationSignpostProto.TextEncoded()
    }
    set {signpost = .textEncoded(newValue)}
  }

  public var imageEncoded: ImageGenerationSignpostProto.ImageEncoded {
    get {
      if case .imageEncoded(let v)? = signpost {return v}
      return ImageGenerationSignpostProto.ImageEncoded()
    }
    set {signpost = .imageEncoded(newValue)}
  }

  public var sampling: ImageGenerationSignpostProto.Sampling {
    get {
      if case .sampling(let v)? = signpost {return v}
      return ImageGenerationSignpostProto.Sampling()
    }
    set {signpost = .sampling(newValue)}
  }

  public var imageDecoded: ImageGenerationSignpostProto.ImageDecoded {
    get {
      if case .imageDecoded(let v)? = signpost {return v}
      return ImageGenerationSignpostProto.ImageDecoded()
    }
    set {signpost = .imageDecoded(newValue)}
  }

  public var secondPassImageEncoded: ImageGenerationSignpostProto.SecondPassImageEncoded {
    get {
      if case .secondPassImageEncoded(let v)? = signpost {return v}
      return ImageGenerationSignpostProto.SecondPassImageEncoded()
    }
    set {signpost = .secondPassImageEncoded(newValue)}
  }

  public var secondPassSampling: ImageGenerationSignpostProto.SecondPassSampling {
    get {
      if case .secondPassSampling(let v)? = signpost {return v}
      return ImageGenerationSignpostProto.SecondPassSampling()
    }
    set {signpost = .secondPassSampling(newValue)}
  }

  public var secondPassImageDecoded: ImageGenerationSignpostProto.SecondPassImageDecoded {
    get {
      if case .secondPassImageDecoded(let v)? = signpost {return v}
      return ImageGenerationSignpostProto.SecondPassImageDecoded()
    }
    set {signpost = .secondPassImageDecoded(newValue)}
  }

  public var faceRestored: ImageGenerationSignpostProto.FaceRestored {
    get {
      if case .faceRestored(let v)? = signpost {return v}
      return ImageGenerationSignpostProto.FaceRestored()
    }
    set {signpost = .faceRestored(newValue)}
  }

  public var imageUpscaled: ImageGenerationSignpostProto.ImageUpscaled {
    get {
      if case .imageUpscaled(let v)? = signpost {return v}
      return ImageGenerationSignpostProto.ImageUpscaled()
    }
    set {signpost = .imageUpscaled(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Signpost: Equatable, Sendable {
    case textEncoded(ImageGenerationSignpostProto.TextEncoded)
    case imageEncoded(ImageGenerationSignpostProto.ImageEncoded)
    case sampling(ImageGenerationSignpostProto.Sampling)
    case imageDecoded(ImageGenerationSignpostProto.ImageDecoded)
    case secondPassImageEncoded(ImageGenerationSignpostProto.SecondPassImageEncoded)
    case secondPassSampling(ImageGenerationSignpostProto.SecondPassSampling)
    case secondPassImageDecoded(ImageGenerationSignpostProto.SecondPassImageDecoded)
    case faceRestored(ImageGenerationSignpostProto.FaceRestored)
    case imageUpscaled(ImageGenerationSignpostProto.ImageUpscaled)

  }

  public struct TextEncoded: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct ImageEncoded: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Sampling: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var step: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct ImageDecoded: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct SecondPassImageEncoded: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct SecondPassSampling: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var step: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct SecondPassImageDecoded: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct FaceRestored: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct ImageUpscaled: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct RemoteDownloadResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var bytesReceived: Int64 = 0

  public var bytesExpected: Int64 = 0

  public var item: Int32 = 0

  public var itemsExpected: Int32 = 0

  public var tag: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ImageGenerationResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Generated image data as bytes.
  public var generatedImages: [Data] = []

  /// Single current signpost.
  public var currentSignpost: ImageGenerationSignpostProto {
    get {return _currentSignpost ?? ImageGenerationSignpostProto()}
    set {_currentSignpost = newValue}
  }
  /// Returns true if `currentSignpost` has been explicitly set.
  public var hasCurrentSignpost: Bool {return self._currentSignpost != nil}
  /// Clears the value of `currentSignpost`. Subsequent reads from it will return its default value.
  public mutating func clearCurrentSignpost() {self._currentSignpost = nil}

  /// Collection of signposts.
  public var signposts: [ImageGenerationSignpostProto] = []

  /// preview generating image data as bytes.
  public var previewImage: Data {
    get {return _previewImage ?? Data()}
    set {_previewImage = newValue}
  }
  /// Returns true if `previewImage` has been explicitly set.
  public var hasPreviewImage: Bool {return self._previewImage != nil}
  /// Clears the value of `previewImage`. Subsequent reads from it will return its default value.
  public mutating func clearPreviewImage() {self._previewImage = nil}

  /// The scale factor of the image.
  public var scaleFactor: Int32 {
    get {return _scaleFactor ?? 0}
    set {_scaleFactor = newValue}
  }
  /// Returns true if `scaleFactor` has been explicitly set.
  public var hasScaleFactor: Bool {return self._scaleFactor != nil}
  /// Clears the value of `scaleFactor`. Subsequent reads from it will return its default value.
  public mutating func clearScaleFactor() {self._scaleFactor = nil}

  /// Tags to track which server responded to the generation request.
  public var tags: [String] = []

  /// The size of final image will be sent in the next payload.
  public var downloadSize: Int64 {
    get {return _downloadSize ?? 0}
    set {_downloadSize = newValue}
  }
  /// Returns true if `downloadSize` has been explicitly set.
  public var hasDownloadSize: Bool {return self._downloadSize != nil}
  /// Clears the value of `downloadSize`. Subsequent reads from it will return its default value.
  public mutating func clearDownloadSize() {self._downloadSize = nil}

  /// What's this chunk is, it helps to compose the chunks together.
  public var chunkState: ChunkState = .lastChunk

  /// If the remote needs to download something, which are they.
  public var remoteDownload: RemoteDownloadResponse {
    get {return _remoteDownload ?? RemoteDownloadResponse()}
    set {_remoteDownload = newValue}
  }
  /// Returns true if `remoteDownload` has been explicitly set.
  public var hasRemoteDownload: Bool {return self._remoteDownload != nil}
  /// Clears the value of `remoteDownload`. Subsequent reads from it will return its default value.
  public mutating func clearRemoteDownload() {self._remoteDownload = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _currentSignpost: ImageGenerationSignpostProto? = nil
  fileprivate var _previewImage: Data? = nil
  fileprivate var _scaleFactor: Int32? = nil
  fileprivate var _downloadSize: Int64? = nil
  fileprivate var _remoteDownload: RemoteDownloadResponse? = nil
}

public struct FileChunk: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var content: Data = Data()

  public var filename: String = String()

  public var offset: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct InitUploadRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the file to be uploaded.
  public var filename: String = String()

  /// SHA-256 hash of the file.
  public var sha256: Data = Data()

  /// Total size of the file in bytes.
  public var totalSize: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct UploadResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chunkUploadSuccess: Bool = false

  public var receivedOffset: Int64 = 0

  public var message: String = String()

  public var filename: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Union type for either an InitUploadRequest or FileChunk.
public struct FileUploadRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var request: FileUploadRequest.OneOf_Request? = nil

  /// Initial upload request to sync SHA and filename.
  public var initRequest: InitUploadRequest {
    get {
      if case .initRequest(let v)? = request {return v}
      return InitUploadRequest()
    }
    set {request = .initRequest(newValue)}
  }

  /// File chunk data.
  public var chunk: FileChunk {
    get {
      if case .chunk(let v)? = request {return v}
      return FileChunk()
    }
    set {request = .chunk(newValue)}
  }

  /// The secret use to authenticate if needed.
  public var sharedSecret: String {
    get {return _sharedSecret ?? String()}
    set {_sharedSecret = newValue}
  }
  /// Returns true if `sharedSecret` has been explicitly set.
  public var hasSharedSecret: Bool {return self._sharedSecret != nil}
  /// Clears the value of `sharedSecret`. Subsequent reads from it will return its default value.
  public mutating func clearSharedSecret() {self._sharedSecret = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Request: Equatable, Sendable {
    /// Initial upload request to sync SHA and filename.
    case initRequest(InitUploadRequest)
    /// File chunk data.
    case chunk(FileChunk)

  }

  public init() {}

  fileprivate var _sharedSecret: String? = nil
}

public struct PubkeyRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct PubkeyResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var message: String = String()

  public var pubkey: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct HoursRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct HoursResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The thresholds currently imposed by the server.
  public var thresholds: ComputeUnitThreshold {
    get {return _thresholds ?? ComputeUnitThreshold()}
    set {_thresholds = newValue}
  }
  /// Returns true if `thresholds` has been explicitly set.
  public var hasThresholds: Bool {return self._thresholds != nil}
  /// Clears the value of `thresholds`. Subsequent reads from it will return its default value.
  public mutating func clearThresholds() {self._thresholds = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _thresholds: ComputeUnitThreshold? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension DeviceType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PHONE"),
    1: .same(proto: "TABLET"),
    2: .same(proto: "LAPTOP"),
  ]
}

extension ChunkState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LAST_CHUNK"),
    1: .same(proto: "MORE_CHUNKS"),
  ]
}

extension EchoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "EchoRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "sharedSecret"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._sharedSecret) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try { if let v = self._sharedSecret {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EchoRequest, rhs: EchoRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._sharedSecret != rhs._sharedSecret {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ComputeUnitThreshold: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ComputeUnitThreshold"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "community"),
    2: .same(proto: "plus"),
    3: .same(proto: "expireAt"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.community) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.plus) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.expireAt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.community.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.community, fieldNumber: 1)
    }
    if self.plus.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.plus, fieldNumber: 2)
    }
    if self.expireAt != 0 {
      try visitor.visitSingularInt64Field(value: self.expireAt, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ComputeUnitThreshold, rhs: ComputeUnitThreshold) -> Bool {
    if lhs.community != rhs.community {return false}
    if lhs.plus != rhs.plus {return false}
    if lhs.expireAt != rhs.expireAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EchoReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "EchoReply"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
    2: .same(proto: "files"),
    3: .same(proto: "override"),
    4: .same(proto: "sharedSecretMissing"),
    5: .same(proto: "thresholds"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.files) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._override) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.sharedSecretMissing) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._thresholds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    if !self.files.isEmpty {
      try visitor.visitRepeatedStringField(value: self.files, fieldNumber: 2)
    }
    try { if let v = self._override {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.sharedSecretMissing != false {
      try visitor.visitSingularBoolField(value: self.sharedSecretMissing, fieldNumber: 4)
    }
    try { if let v = self._thresholds {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EchoReply, rhs: EchoReply) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.files != rhs.files {return false}
    if lhs._override != rhs._override {return false}
    if lhs.sharedSecretMissing != rhs.sharedSecretMissing {return false}
    if lhs._thresholds != rhs._thresholds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FileListRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "FileListRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "files"),
    2: .same(proto: "filesWithHash"),
    3: .same(proto: "sharedSecret"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.files) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.filesWithHash) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._sharedSecret) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.files.isEmpty {
      try visitor.visitRepeatedStringField(value: self.files, fieldNumber: 1)
    }
    if !self.filesWithHash.isEmpty {
      try visitor.visitRepeatedStringField(value: self.filesWithHash, fieldNumber: 2)
    }
    try { if let v = self._sharedSecret {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FileListRequest, rhs: FileListRequest) -> Bool {
    if lhs.files != rhs.files {return false}
    if lhs.filesWithHash != rhs.filesWithHash {return false}
    if lhs._sharedSecret != rhs._sharedSecret {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FileExistenceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "FileExistenceResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "files"),
    2: .same(proto: "existences"),
    3: .same(proto: "hashes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.files) }()
      case 2: try { try decoder.decodeRepeatedBoolField(value: &self.existences) }()
      case 3: try { try decoder.decodeRepeatedBytesField(value: &self.hashes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.files.isEmpty {
      try visitor.visitRepeatedStringField(value: self.files, fieldNumber: 1)
    }
    if !self.existences.isEmpty {
      try visitor.visitPackedBoolField(value: self.existences, fieldNumber: 2)
    }
    if !self.hashes.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.hashes, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FileExistenceResponse, rhs: FileExistenceResponse) -> Bool {
    if lhs.files != rhs.files {return false}
    if lhs.existences != rhs.existences {return false}
    if lhs.hashes != rhs.hashes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MetadataOverride: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "MetadataOverride"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "models"),
    2: .same(proto: "loras"),
    3: .same(proto: "controlNets"),
    4: .same(proto: "textualInversions"),
    5: .same(proto: "upscalers"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.models) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.loras) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.controlNets) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.textualInversions) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.upscalers) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.models.isEmpty {
      try visitor.visitSingularBytesField(value: self.models, fieldNumber: 1)
    }
    if !self.loras.isEmpty {
      try visitor.visitSingularBytesField(value: self.loras, fieldNumber: 2)
    }
    if !self.controlNets.isEmpty {
      try visitor.visitSingularBytesField(value: self.controlNets, fieldNumber: 3)
    }
    if !self.textualInversions.isEmpty {
      try visitor.visitSingularBytesField(value: self.textualInversions, fieldNumber: 4)
    }
    if !self.upscalers.isEmpty {
      try visitor.visitSingularBytesField(value: self.upscalers, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MetadataOverride, rhs: MetadataOverride) -> Bool {
    if lhs.models != rhs.models {return false}
    if lhs.loras != rhs.loras {return false}
    if lhs.controlNets != rhs.controlNets {return false}
    if lhs.textualInversions != rhs.textualInversions {return false}
    if lhs.upscalers != rhs.upscalers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ImageGenerationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ImageGenerationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "image"),
    2: .same(proto: "scaleFactor"),
    3: .same(proto: "mask"),
    4: .same(proto: "hints"),
    5: .same(proto: "prompt"),
    6: .same(proto: "negativePrompt"),
    7: .same(proto: "configuration"),
    8: .same(proto: "override"),
    9: .same(proto: "keywords"),
    10: .same(proto: "user"),
    11: .same(proto: "device"),
    12: .same(proto: "contents"),
    13: .same(proto: "sharedSecret"),
    14: .same(proto: "chunked"),
  ]

  fileprivate class _StorageClass {
    var _image: Data? = nil
    var _scaleFactor: Int32 = 0
    var _mask: Data? = nil
    var _hints: [HintProto] = []
    var _prompt: String = String()
    var _negativePrompt: String = String()
    var _configuration: Data = Data()
    var _override: MetadataOverride? = nil
    var _keywords: [String] = []
    var _user: String = String()
    var _device: DeviceType = .phone
    var _contents: [Data] = []
    var _sharedSecret: String? = nil
    var _chunked: Bool = false

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _image = source._image
      _scaleFactor = source._scaleFactor
      _mask = source._mask
      _hints = source._hints
      _prompt = source._prompt
      _negativePrompt = source._negativePrompt
      _configuration = source._configuration
      _override = source._override
      _keywords = source._keywords
      _user = source._user
      _device = source._device
      _contents = source._contents
      _sharedSecret = source._sharedSecret
      _chunked = source._chunked
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBytesField(value: &_storage._image) }()
        case 2: try { try decoder.decodeSingularInt32Field(value: &_storage._scaleFactor) }()
        case 3: try { try decoder.decodeSingularBytesField(value: &_storage._mask) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._hints) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._prompt) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._negativePrompt) }()
        case 7: try { try decoder.decodeSingularBytesField(value: &_storage._configuration) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._override) }()
        case 9: try { try decoder.decodeRepeatedStringField(value: &_storage._keywords) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._user) }()
        case 11: try { try decoder.decodeSingularEnumField(value: &_storage._device) }()
        case 12: try { try decoder.decodeRepeatedBytesField(value: &_storage._contents) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._sharedSecret) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._chunked) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._image {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
      } }()
      if _storage._scaleFactor != 0 {
        try visitor.visitSingularInt32Field(value: _storage._scaleFactor, fieldNumber: 2)
      }
      try { if let v = _storage._mask {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
      } }()
      if !_storage._hints.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._hints, fieldNumber: 4)
      }
      if !_storage._prompt.isEmpty {
        try visitor.visitSingularStringField(value: _storage._prompt, fieldNumber: 5)
      }
      if !_storage._negativePrompt.isEmpty {
        try visitor.visitSingularStringField(value: _storage._negativePrompt, fieldNumber: 6)
      }
      if !_storage._configuration.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._configuration, fieldNumber: 7)
      }
      try { if let v = _storage._override {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if !_storage._keywords.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._keywords, fieldNumber: 9)
      }
      if !_storage._user.isEmpty {
        try visitor.visitSingularStringField(value: _storage._user, fieldNumber: 10)
      }
      if _storage._device != .phone {
        try visitor.visitSingularEnumField(value: _storage._device, fieldNumber: 11)
      }
      if !_storage._contents.isEmpty {
        try visitor.visitRepeatedBytesField(value: _storage._contents, fieldNumber: 12)
      }
      try { if let v = _storage._sharedSecret {
        try visitor.visitSingularStringField(value: v, fieldNumber: 13)
      } }()
      if _storage._chunked != false {
        try visitor.visitSingularBoolField(value: _storage._chunked, fieldNumber: 14)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ImageGenerationRequest, rhs: ImageGenerationRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._image != rhs_storage._image {return false}
        if _storage._scaleFactor != rhs_storage._scaleFactor {return false}
        if _storage._mask != rhs_storage._mask {return false}
        if _storage._hints != rhs_storage._hints {return false}
        if _storage._prompt != rhs_storage._prompt {return false}
        if _storage._negativePrompt != rhs_storage._negativePrompt {return false}
        if _storage._configuration != rhs_storage._configuration {return false}
        if _storage._override != rhs_storage._override {return false}
        if _storage._keywords != rhs_storage._keywords {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._device != rhs_storage._device {return false}
        if _storage._contents != rhs_storage._contents {return false}
        if _storage._sharedSecret != rhs_storage._sharedSecret {return false}
        if _storage._chunked != rhs_storage._chunked {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HintProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "HintProto"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hintType"),
    2: .same(proto: "tensors"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.hintType) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.tensors) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hintType.isEmpty {
      try visitor.visitSingularStringField(value: self.hintType, fieldNumber: 1)
    }
    if !self.tensors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tensors, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: HintProto, rhs: HintProto) -> Bool {
    if lhs.hintType != rhs.hintType {return false}
    if lhs.tensors != rhs.tensors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TensorAndWeight: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "TensorAndWeight"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tensor"),
    2: .same(proto: "weight"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.tensor) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.weight) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tensor.isEmpty {
      try visitor.visitSingularBytesField(value: self.tensor, fieldNumber: 1)
    }
    if self.weight.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.weight, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TensorAndWeight, rhs: TensorAndWeight) -> Bool {
    if lhs.tensor != rhs.tensor {return false}
    if lhs.weight != rhs.weight {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ImageGenerationSignpostProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ImageGenerationSignpostProto"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "textEncoded"),
    2: .same(proto: "imageEncoded"),
    3: .same(proto: "sampling"),
    4: .same(proto: "imageDecoded"),
    5: .same(proto: "secondPassImageEncoded"),
    6: .same(proto: "secondPassSampling"),
    7: .same(proto: "secondPassImageDecoded"),
    8: .same(proto: "faceRestored"),
    9: .same(proto: "imageUpscaled"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: ImageGenerationSignpostProto.TextEncoded?
        var hadOneofValue = false
        if let current = self.signpost {
          hadOneofValue = true
          if case .textEncoded(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.signpost = .textEncoded(v)
        }
      }()
      case 2: try {
        var v: ImageGenerationSignpostProto.ImageEncoded?
        var hadOneofValue = false
        if let current = self.signpost {
          hadOneofValue = true
          if case .imageEncoded(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.signpost = .imageEncoded(v)
        }
      }()
      case 3: try {
        var v: ImageGenerationSignpostProto.Sampling?
        var hadOneofValue = false
        if let current = self.signpost {
          hadOneofValue = true
          if case .sampling(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.signpost = .sampling(v)
        }
      }()
      case 4: try {
        var v: ImageGenerationSignpostProto.ImageDecoded?
        var hadOneofValue = false
        if let current = self.signpost {
          hadOneofValue = true
          if case .imageDecoded(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.signpost = .imageDecoded(v)
        }
      }()
      case 5: try {
        var v: ImageGenerationSignpostProto.SecondPassImageEncoded?
        var hadOneofValue = false
        if let current = self.signpost {
          hadOneofValue = true
          if case .secondPassImageEncoded(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.signpost = .secondPassImageEncoded(v)
        }
      }()
      case 6: try {
        var v: ImageGenerationSignpostProto.SecondPassSampling?
        var hadOneofValue = false
        if let current = self.signpost {
          hadOneofValue = true
          if case .secondPassSampling(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.signpost = .secondPassSampling(v)
        }
      }()
      case 7: try {
        var v: ImageGenerationSignpostProto.SecondPassImageDecoded?
        var hadOneofValue = false
        if let current = self.signpost {
          hadOneofValue = true
          if case .secondPassImageDecoded(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.signpost = .secondPassImageDecoded(v)
        }
      }()
      case 8: try {
        var v: ImageGenerationSignpostProto.FaceRestored?
        var hadOneofValue = false
        if let current = self.signpost {
          hadOneofValue = true
          if case .faceRestored(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.signpost = .faceRestored(v)
        }
      }()
      case 9: try {
        var v: ImageGenerationSignpostProto.ImageUpscaled?
        var hadOneofValue = false
        if let current = self.signpost {
          hadOneofValue = true
          if case .imageUpscaled(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.signpost = .imageUpscaled(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.signpost {
    case .textEncoded?: try {
      guard case .textEncoded(let v)? = self.signpost else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .imageEncoded?: try {
      guard case .imageEncoded(let v)? = self.signpost else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .sampling?: try {
      guard case .sampling(let v)? = self.signpost else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .imageDecoded?: try {
      guard case .imageDecoded(let v)? = self.signpost else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .secondPassImageEncoded?: try {
      guard case .secondPassImageEncoded(let v)? = self.signpost else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .secondPassSampling?: try {
      guard case .secondPassSampling(let v)? = self.signpost else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .secondPassImageDecoded?: try {
      guard case .secondPassImageDecoded(let v)? = self.signpost else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .faceRestored?: try {
      guard case .faceRestored(let v)? = self.signpost else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .imageUpscaled?: try {
      guard case .imageUpscaled(let v)? = self.signpost else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ImageGenerationSignpostProto, rhs: ImageGenerationSignpostProto) -> Bool {
    if lhs.signpost != rhs.signpost {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ImageGenerationSignpostProto.TextEncoded: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ImageGenerationSignpostProto.protoMessageName + ".TextEncoded"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ImageGenerationSignpostProto.TextEncoded, rhs: ImageGenerationSignpostProto.TextEncoded) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ImageGenerationSignpostProto.ImageEncoded: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ImageGenerationSignpostProto.protoMessageName + ".ImageEncoded"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ImageGenerationSignpostProto.ImageEncoded, rhs: ImageGenerationSignpostProto.ImageEncoded) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ImageGenerationSignpostProto.Sampling: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ImageGenerationSignpostProto.protoMessageName + ".Sampling"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "step"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.step) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.step != 0 {
      try visitor.visitSingularInt32Field(value: self.step, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ImageGenerationSignpostProto.Sampling, rhs: ImageGenerationSignpostProto.Sampling) -> Bool {
    if lhs.step != rhs.step {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ImageGenerationSignpostProto.ImageDecoded: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ImageGenerationSignpostProto.protoMessageName + ".ImageDecoded"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ImageGenerationSignpostProto.ImageDecoded, rhs: ImageGenerationSignpostProto.ImageDecoded) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ImageGenerationSignpostProto.SecondPassImageEncoded: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ImageGenerationSignpostProto.protoMessageName + ".SecondPassImageEncoded"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ImageGenerationSignpostProto.SecondPassImageEncoded, rhs: ImageGenerationSignpostProto.SecondPassImageEncoded) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ImageGenerationSignpostProto.SecondPassSampling: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ImageGenerationSignpostProto.protoMessageName + ".SecondPassSampling"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "step"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.step) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.step != 0 {
      try visitor.visitSingularInt32Field(value: self.step, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ImageGenerationSignpostProto.SecondPassSampling, rhs: ImageGenerationSignpostProto.SecondPassSampling) -> Bool {
    if lhs.step != rhs.step {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ImageGenerationSignpostProto.SecondPassImageDecoded: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ImageGenerationSignpostProto.protoMessageName + ".SecondPassImageDecoded"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ImageGenerationSignpostProto.SecondPassImageDecoded, rhs: ImageGenerationSignpostProto.SecondPassImageDecoded) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ImageGenerationSignpostProto.FaceRestored: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ImageGenerationSignpostProto.protoMessageName + ".FaceRestored"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ImageGenerationSignpostProto.FaceRestored, rhs: ImageGenerationSignpostProto.FaceRestored) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ImageGenerationSignpostProto.ImageUpscaled: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ImageGenerationSignpostProto.protoMessageName + ".ImageUpscaled"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ImageGenerationSignpostProto.ImageUpscaled, rhs: ImageGenerationSignpostProto.ImageUpscaled) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RemoteDownloadResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "RemoteDownloadResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bytesReceived"),
    2: .same(proto: "bytesExpected"),
    3: .same(proto: "item"),
    4: .same(proto: "itemsExpected"),
    5: .same(proto: "tag"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.bytesReceived) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.bytesExpected) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.item) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.itemsExpected) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.tag) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.bytesReceived != 0 {
      try visitor.visitSingularInt64Field(value: self.bytesReceived, fieldNumber: 1)
    }
    if self.bytesExpected != 0 {
      try visitor.visitSingularInt64Field(value: self.bytesExpected, fieldNumber: 2)
    }
    if self.item != 0 {
      try visitor.visitSingularInt32Field(value: self.item, fieldNumber: 3)
    }
    if self.itemsExpected != 0 {
      try visitor.visitSingularInt32Field(value: self.itemsExpected, fieldNumber: 4)
    }
    if !self.tag.isEmpty {
      try visitor.visitSingularStringField(value: self.tag, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RemoteDownloadResponse, rhs: RemoteDownloadResponse) -> Bool {
    if lhs.bytesReceived != rhs.bytesReceived {return false}
    if lhs.bytesExpected != rhs.bytesExpected {return false}
    if lhs.item != rhs.item {return false}
    if lhs.itemsExpected != rhs.itemsExpected {return false}
    if lhs.tag != rhs.tag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ImageGenerationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ImageGenerationResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "generatedImages"),
    2: .same(proto: "currentSignpost"),
    3: .same(proto: "signposts"),
    4: .same(proto: "previewImage"),
    5: .same(proto: "scaleFactor"),
    6: .same(proto: "tags"),
    7: .same(proto: "downloadSize"),
    8: .same(proto: "chunkState"),
    9: .same(proto: "remoteDownload"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBytesField(value: &self.generatedImages) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._currentSignpost) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.signposts) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self._previewImage) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self._scaleFactor) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.tags) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self._downloadSize) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.chunkState) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._remoteDownload) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.generatedImages.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.generatedImages, fieldNumber: 1)
    }
    try { if let v = self._currentSignpost {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.signposts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.signposts, fieldNumber: 3)
    }
    try { if let v = self._previewImage {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._scaleFactor {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
    } }()
    if !self.tags.isEmpty {
      try visitor.visitRepeatedStringField(value: self.tags, fieldNumber: 6)
    }
    try { if let v = self._downloadSize {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 7)
    } }()
    if self.chunkState != .lastChunk {
      try visitor.visitSingularEnumField(value: self.chunkState, fieldNumber: 8)
    }
    try { if let v = self._remoteDownload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ImageGenerationResponse, rhs: ImageGenerationResponse) -> Bool {
    if lhs.generatedImages != rhs.generatedImages {return false}
    if lhs._currentSignpost != rhs._currentSignpost {return false}
    if lhs.signposts != rhs.signposts {return false}
    if lhs._previewImage != rhs._previewImage {return false}
    if lhs._scaleFactor != rhs._scaleFactor {return false}
    if lhs.tags != rhs.tags {return false}
    if lhs._downloadSize != rhs._downloadSize {return false}
    if lhs.chunkState != rhs.chunkState {return false}
    if lhs._remoteDownload != rhs._remoteDownload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FileChunk: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "FileChunk"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "content"),
    2: .same(proto: "filename"),
    3: .same(proto: "offset"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.content) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.filename) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.content.isEmpty {
      try visitor.visitSingularBytesField(value: self.content, fieldNumber: 1)
    }
    if !self.filename.isEmpty {
      try visitor.visitSingularStringField(value: self.filename, fieldNumber: 2)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FileChunk, rhs: FileChunk) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.filename != rhs.filename {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension InitUploadRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "InitUploadRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "filename"),
    2: .same(proto: "sha256"),
    3: .same(proto: "totalSize"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.filename) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.sha256) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.totalSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.filename.isEmpty {
      try visitor.visitSingularStringField(value: self.filename, fieldNumber: 1)
    }
    if !self.sha256.isEmpty {
      try visitor.visitSingularBytesField(value: self.sha256, fieldNumber: 2)
    }
    if self.totalSize != 0 {
      try visitor.visitSingularInt64Field(value: self.totalSize, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: InitUploadRequest, rhs: InitUploadRequest) -> Bool {
    if lhs.filename != rhs.filename {return false}
    if lhs.sha256 != rhs.sha256 {return false}
    if lhs.totalSize != rhs.totalSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UploadResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UploadResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chunkUploadSuccess"),
    2: .same(proto: "receivedOffset"),
    3: .same(proto: "message"),
    4: .same(proto: "filename"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.chunkUploadSuccess) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.receivedOffset) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.filename) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.chunkUploadSuccess != false {
      try visitor.visitSingularBoolField(value: self.chunkUploadSuccess, fieldNumber: 1)
    }
    if self.receivedOffset != 0 {
      try visitor.visitSingularInt64Field(value: self.receivedOffset, fieldNumber: 2)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 3)
    }
    if !self.filename.isEmpty {
      try visitor.visitSingularStringField(value: self.filename, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UploadResponse, rhs: UploadResponse) -> Bool {
    if lhs.chunkUploadSuccess != rhs.chunkUploadSuccess {return false}
    if lhs.receivedOffset != rhs.receivedOffset {return false}
    if lhs.message != rhs.message {return false}
    if lhs.filename != rhs.filename {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FileUploadRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "FileUploadRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "initRequest"),
    2: .same(proto: "chunk"),
    3: .same(proto: "sharedSecret"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: InitUploadRequest?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .initRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .initRequest(v)
        }
      }()
      case 2: try {
        var v: FileChunk?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .chunk(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .chunk(v)
        }
      }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._sharedSecret) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.request {
    case .initRequest?: try {
      guard case .initRequest(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .chunk?: try {
      guard case .chunk(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try { if let v = self._sharedSecret {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FileUploadRequest, rhs: FileUploadRequest) -> Bool {
    if lhs.request != rhs.request {return false}
    if lhs._sharedSecret != rhs._sharedSecret {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PubkeyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PubkeyRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PubkeyRequest, rhs: PubkeyRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PubkeyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PubkeyResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
    2: .same(proto: "pubkey"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pubkey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    if !self.pubkey.isEmpty {
      try visitor.visitSingularStringField(value: self.pubkey, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PubkeyResponse, rhs: PubkeyResponse) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.pubkey != rhs.pubkey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HoursRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "HoursRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: HoursRequest, rhs: HoursRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HoursResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "HoursResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "thresholds"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._thresholds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._thresholds {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: HoursResponse, rhs: HoursResponse) -> Bool {
    if lhs._thresholds != rhs._thresholds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
