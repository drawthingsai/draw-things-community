// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public enum zzz_DflatGen_SamplerType: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case dpmpp2mkarras = 0
  case eulera = 1
  case ddim = 2
  case plms = 3
  case dpmppsdekarras = 4
  case unipc = 5
  case lcm = 6
  case eulerasubstep = 7
  case dpmppsdesubstep = 8
  case tcd = 9
  case euleratrailing = 10
  case dpmppsdetrailing = 11
  case dpmpp2mays = 12
  case euleraays = 13
  case dpmppsdeays = 14
  case dpmpp2mtrailing = 15
  case ddimtrailing = 16
  case unipctrailing = 17
  case unipcays = 18

  public static var max: zzz_DflatGen_SamplerType { return .unipcays }
  public static var min: zzz_DflatGen_SamplerType { return .dpmpp2mkarras }
}

public enum zzz_DflatGen_SeedMode: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case legacy = 0
  case torchcpucompatible = 1
  case scalealike = 2
  case nvidiagpucompatible = 3

  public static var max: zzz_DflatGen_SeedMode { return .nvidiagpucompatible }
  public static var min: zzz_DflatGen_SeedMode { return .legacy }
}

public enum zzz_DflatGen_ControlMode: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case balanced = 0
  case prompt = 1
  case control = 2

  public static var max: zzz_DflatGen_ControlMode { return .control }
  public static var min: zzz_DflatGen_ControlMode { return .balanced }
}

public enum zzz_DflatGen_ControlInputType: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case unspecified = 0
  case custom = 1
  case depth = 2
  case canny = 3
  case scribble = 4
  case pose = 5
  case normalbae = 6
  case color = 7
  case lineart = 8
  case softedge = 9
  case seg = 10
  case inpaint = 11
  case ip2p = 12
  case shuffle = 13
  case mlsd = 14
  case tile = 15
  case blur = 16
  case lowquality = 17
  case gray = 18

  public static var max: zzz_DflatGen_ControlInputType { return .gray }
  public static var min: zzz_DflatGen_ControlInputType { return .unspecified }
}

public enum zzz_DflatGen_LoRAMode: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case all = 0
  case base = 1
  case refiner = 2

  public static var max: zzz_DflatGen_LoRAMode { return .refiner }
  public static var min: zzz_DflatGen_LoRAMode { return .all }
}

public enum zzz_DflatGen_CompressionMethod: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case disabled = 0
  case h264 = 1
  case h265 = 2
  case jpeg = 3

  public static var max: zzz_DflatGen_CompressionMethod { return .jpeg }
  public static var min: zzz_DflatGen_CompressionMethod { return .disabled }
}

public struct zzz_DflatGen_Control: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_22_9_29() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static func getRootAsControl(bb: ByteBuffer) -> zzz_DflatGen_Control {
    return zzz_DflatGen_Control(
      Table(
        bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))
    )
  }

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case file = 4
    case weight = 6
    case guidanceStart = 8
    case guidanceEnd = 10
    case noPrompt = 12
    case globalAveragePooling = 14
    case downSamplingRate = 16
    case controlMode = 18
    case targetBlocks = 20
    case inputOverride = 22
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var file: String? {
    let o = _accessor.offset(VTOFFSET.file.v)
    return o == 0 ? nil : _accessor.string(at: o)
  }
  public var fileSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.file.v) }
  public var weight: Float32 {
    let o = _accessor.offset(VTOFFSET.weight.v)
    return o == 0 ? 1.0 : _accessor.readBuffer(of: Float32.self, at: o)
  }
  public var guidanceStart: Float32 {
    let o = _accessor.offset(VTOFFSET.guidanceStart.v)
    return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o)
  }
  public var guidanceEnd: Float32 {
    let o = _accessor.offset(VTOFFSET.guidanceEnd.v)
    return o == 0 ? 1.0 : _accessor.readBuffer(of: Float32.self, at: o)
  }
  public var noPrompt: Bool {
    let o = _accessor.offset(VTOFFSET.noPrompt.v)
    return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o)
  }
  public var globalAveragePooling: Bool {
    let o = _accessor.offset(VTOFFSET.globalAveragePooling.v)
    return o == 0 ? true : 0 != _accessor.readBuffer(of: Byte.self, at: o)
  }
  public var downSamplingRate: Float32 {
    let o = _accessor.offset(VTOFFSET.downSamplingRate.v)
    return o == 0 ? 1.0 : _accessor.readBuffer(of: Float32.self, at: o)
  }
  public var controlMode: zzz_DflatGen_ControlMode {
    let o = _accessor.offset(VTOFFSET.controlMode.v)
    return o == 0
      ? .balanced
      : zzz_DflatGen_ControlMode(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .balanced
  }
  public var hasTargetBlocks: Bool {
    let o = _accessor.offset(VTOFFSET.targetBlocks.v)
    return o == 0 ? false : true
  }
  public var targetBlocksCount: Int32 {
    let o = _accessor.offset(VTOFFSET.targetBlocks.v)
    return o == 0 ? 0 : _accessor.vector(count: o)
  }
  public func targetBlocks(at index: Int32) -> String? {
    let o = _accessor.offset(VTOFFSET.targetBlocks.v)
    return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4)
  }
  public var inputOverride: zzz_DflatGen_ControlInputType {
    let o = _accessor.offset(VTOFFSET.inputOverride.v)
    return o == 0
      ? .unspecified
      : zzz_DflatGen_ControlInputType(rawValue: _accessor.readBuffer(of: Int8.self, at: o))
        ?? .unspecified
  }
  public static func startControl(_ fbb: inout FlatBufferBuilder) -> UOffset {
    fbb.startTable(with: 10)
  }
  public static func add(file: Offset, _ fbb: inout FlatBufferBuilder) {
    fbb.add(offset: file, at: VTOFFSET.file.p)
  }
  public static func add(weight: Float32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: weight, def: 1.0, at: VTOFFSET.weight.p)
  }
  public static func add(guidanceStart: Float32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: guidanceStart, def: 0.0, at: VTOFFSET.guidanceStart.p)
  }
  public static func add(guidanceEnd: Float32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: guidanceEnd, def: 1.0, at: VTOFFSET.guidanceEnd.p)
  }
  public static func add(noPrompt: Bool, _ fbb: inout FlatBufferBuilder) {
    fbb.add(
      element: noPrompt, def: false,
      at: VTOFFSET.noPrompt.p)
  }
  public static func add(globalAveragePooling: Bool, _ fbb: inout FlatBufferBuilder) {
    fbb.add(
      element: globalAveragePooling, def: true,
      at: VTOFFSET.globalAveragePooling.p)
  }
  public static func add(downSamplingRate: Float32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: downSamplingRate, def: 1.0, at: VTOFFSET.downSamplingRate.p)
  }
  public static func add(controlMode: zzz_DflatGen_ControlMode, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: controlMode.rawValue, def: 0, at: VTOFFSET.controlMode.p)
  }
  public static func addVectorOf(targetBlocks: Offset, _ fbb: inout FlatBufferBuilder) {
    fbb.add(offset: targetBlocks, at: VTOFFSET.targetBlocks.p)
  }
  public static func add(
    inputOverride: zzz_DflatGen_ControlInputType, _ fbb: inout FlatBufferBuilder
  ) { fbb.add(element: inputOverride.rawValue, def: 0, at: VTOFFSET.inputOverride.p) }
  public static func endControl(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset {
    let end = Offset(offset: fbb.endTable(at: start))
    return end
  }
  public static func createControl(
    _ fbb: inout FlatBufferBuilder,
    fileOffset file: Offset = Offset(),
    weight: Float32 = 1.0,
    guidanceStart: Float32 = 0.0,
    guidanceEnd: Float32 = 1.0,
    noPrompt: Bool = false,
    globalAveragePooling: Bool = true,
    downSamplingRate: Float32 = 1.0,
    controlMode: zzz_DflatGen_ControlMode = .balanced,
    targetBlocksVectorOffset targetBlocks: Offset = Offset(),
    inputOverride: zzz_DflatGen_ControlInputType = .unspecified
  ) -> Offset {
    let __start = zzz_DflatGen_Control.startControl(&fbb)
    zzz_DflatGen_Control.add(file: file, &fbb)
    zzz_DflatGen_Control.add(weight: weight, &fbb)
    zzz_DflatGen_Control.add(guidanceStart: guidanceStart, &fbb)
    zzz_DflatGen_Control.add(guidanceEnd: guidanceEnd, &fbb)
    zzz_DflatGen_Control.add(noPrompt: noPrompt, &fbb)
    zzz_DflatGen_Control.add(globalAveragePooling: globalAveragePooling, &fbb)
    zzz_DflatGen_Control.add(downSamplingRate: downSamplingRate, &fbb)
    zzz_DflatGen_Control.add(controlMode: controlMode, &fbb)
    zzz_DflatGen_Control.addVectorOf(targetBlocks: targetBlocks, &fbb)
    zzz_DflatGen_Control.add(inputOverride: inputOverride, &fbb)
    return zzz_DflatGen_Control.endControl(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws
  where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(
      field: VTOFFSET.file.p, fieldName: "file", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.weight.p, fieldName: "weight", required: false, type: Float32.self)
    try _v.visit(
      field: VTOFFSET.guidanceStart.p, fieldName: "guidanceStart", required: false,
      type: Float32.self)
    try _v.visit(
      field: VTOFFSET.guidanceEnd.p, fieldName: "guidanceEnd", required: false, type: Float32.self)
    try _v.visit(
      field: VTOFFSET.noPrompt.p, fieldName: "noPrompt", required: false, type: Bool.self)
    try _v.visit(
      field: VTOFFSET.globalAveragePooling.p, fieldName: "globalAveragePooling", required: false,
      type: Bool.self)
    try _v.visit(
      field: VTOFFSET.downSamplingRate.p, fieldName: "downSamplingRate", required: false,
      type: Float32.self)
    try _v.visit(
      field: VTOFFSET.controlMode.p, fieldName: "controlMode", required: false,
      type: zzz_DflatGen_ControlMode.self)
    try _v.visit(
      field: VTOFFSET.targetBlocks.p, fieldName: "targetBlocks", required: false,
      type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(
      field: VTOFFSET.inputOverride.p, fieldName: "inputOverride", required: false,
      type: zzz_DflatGen_ControlInputType.self)
    _v.finish()
  }
}

public struct zzz_DflatGen_LoRA: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_22_9_29() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static func getRootAsLoRA(bb: ByteBuffer) -> zzz_DflatGen_LoRA {
    return zzz_DflatGen_LoRA(
      Table(
        bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))
    )
  }

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case file = 4
    case weight = 6
    case mode = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var file: String? {
    let o = _accessor.offset(VTOFFSET.file.v)
    return o == 0 ? nil : _accessor.string(at: o)
  }
  public var fileSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.file.v) }
  public var weight: Float32 {
    let o = _accessor.offset(VTOFFSET.weight.v)
    return o == 0 ? 0.6 : _accessor.readBuffer(of: Float32.self, at: o)
  }
  public var mode: zzz_DflatGen_LoRAMode {
    let o = _accessor.offset(VTOFFSET.mode.v)
    return o == 0
      ? .all : zzz_DflatGen_LoRAMode(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .all
  }
  public static func startLoRA(_ fbb: inout FlatBufferBuilder) -> UOffset {
    fbb.startTable(with: 3)
  }
  public static func add(file: Offset, _ fbb: inout FlatBufferBuilder) {
    fbb.add(offset: file, at: VTOFFSET.file.p)
  }
  public static func add(weight: Float32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: weight, def: 0.6, at: VTOFFSET.weight.p)
  }
  public static func add(mode: zzz_DflatGen_LoRAMode, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: mode.rawValue, def: 0, at: VTOFFSET.mode.p)
  }
  public static func endLoRA(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset {
    let end = Offset(offset: fbb.endTable(at: start))
    return end
  }
  public static func createLoRA(
    _ fbb: inout FlatBufferBuilder,
    fileOffset file: Offset = Offset(),
    weight: Float32 = 0.6,
    mode: zzz_DflatGen_LoRAMode = .all
  ) -> Offset {
    let __start = zzz_DflatGen_LoRA.startLoRA(&fbb)
    zzz_DflatGen_LoRA.add(file: file, &fbb)
    zzz_DflatGen_LoRA.add(weight: weight, &fbb)
    zzz_DflatGen_LoRA.add(mode: mode, &fbb)
    return zzz_DflatGen_LoRA.endLoRA(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws
  where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(
      field: VTOFFSET.file.p, fieldName: "file", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.weight.p, fieldName: "weight", required: false, type: Float32.self)
    try _v.visit(
      field: VTOFFSET.mode.p, fieldName: "mode", required: false, type: zzz_DflatGen_LoRAMode.self)
    _v.finish()
  }
}

public struct zzz_DflatGen_GenerationConfiguration: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_22_9_29() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static func getRootAsGenerationConfiguration(bb: ByteBuffer)
    -> zzz_DflatGen_GenerationConfiguration
  {
    return zzz_DflatGen_GenerationConfiguration(
      Table(
        bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))
    )
  }

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case id = 4
    case startWidth = 6
    case startHeight = 8
    case seed = 10
    case steps = 12
    case guidanceScale = 14
    case strength = 16
    case model = 18
    case sampler = 20
    case batchCount = 22
    case batchSize = 24
    case hiresFix = 26
    case hiresFixStartWidth = 28
    case hiresFixStartHeight = 30
    case hiresFixStrength = 32
    case upscaler = 34
    case imageGuidanceScale = 36
    case seedMode = 38
    case clipSkip = 40
    case controls = 42
    case loras = 44
    case maskBlur = 46
    case faceRestoration = 48
    case clipWeight = 54
    case negativePromptForImagePrior = 56
    case imagePriorSteps = 58
    case refinerModel = 60
    case originalImageHeight = 62
    case originalImageWidth = 64
    case cropTop = 66
    case cropLeft = 68
    case targetImageHeight = 70
    case targetImageWidth = 72
    case aestheticScore = 74
    case negativeAestheticScore = 76
    case zeroNegativePrompt = 78
    case refinerStart = 80
    case negativeOriginalImageHeight = 82
    case negativeOriginalImageWidth = 84
    case name = 86
    case fpsId = 88
    case motionBucketId = 90
    case condAug = 92
    case startFrameCfg = 94
    case numFrames = 96
    case maskBlurOutset = 98
    case sharpness = 100
    case shift = 102
    case stage2Steps = 104
    case stage2Cfg = 106
    case stage2Shift = 108
    case tiledDecoding = 110
    case decodingTileWidth = 112
    case decodingTileHeight = 114
    case decodingTileOverlap = 116
    case stochasticSamplingGamma = 118
    case preserveOriginalAfterInpaint = 120
    case tiledDiffusion = 122
    case diffusionTileWidth = 124
    case diffusionTileHeight = 126
    case diffusionTileOverlap = 128
    case upscalerScaleFactor = 130
    case t5TextEncoder = 132
    case separateClipL = 134
    case clipLText = 136
    case separateOpenClipG = 138
    case openClipGText = 140
    case speedUpWithGuidanceEmbed = 142
    case guidanceEmbed = 144
    case resolutionDependentShift = 146
    case teaCacheStart = 148
    case teaCacheEnd = 150
    case teaCacheThreshold = 152
    case teaCache = 154
    case separateT5 = 156
    case t5Text = 158
    case teaCacheMaxSkipSteps = 160
    case causalInferenceEnabled = 162
    case causalInference = 164
    case causalInferencePad = 166
    case cfgZeroStar = 168
    case cfgZeroInitSteps = 170
    case compressionArtifacts = 172
    case compressionArtifactsQuality = 174
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var id: Int64 {
    let o = _accessor.offset(VTOFFSET.id.v)
    return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o)
  }
  public var startWidth: UInt16 {
    let o = _accessor.offset(VTOFFSET.startWidth.v)
    return o == 0 ? 0 : _accessor.readBuffer(of: UInt16.self, at: o)
  }
  public var startHeight: UInt16 {
    let o = _accessor.offset(VTOFFSET.startHeight.v)
    return o == 0 ? 0 : _accessor.readBuffer(of: UInt16.self, at: o)
  }
  public var seed: UInt32 {
    let o = _accessor.offset(VTOFFSET.seed.v)
    return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o)
  }
  public var steps: UInt32 {
    let o = _accessor.offset(VTOFFSET.steps.v)
    return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o)
  }
  public var guidanceScale: Float32 {
    let o = _accessor.offset(VTOFFSET.guidanceScale.v)
    return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o)
  }
  public var strength: Float32 {
    let o = _accessor.offset(VTOFFSET.strength.v)
    return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o)
  }
  public var model: String? {
    let o = _accessor.offset(VTOFFSET.model.v)
    return o == 0 ? nil : _accessor.string(at: o)
  }
  public var modelSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.model.v) }
  public var sampler: zzz_DflatGen_SamplerType {
    let o = _accessor.offset(VTOFFSET.sampler.v)
    return o == 0
      ? .dpmpp2mkarras
      : zzz_DflatGen_SamplerType(rawValue: _accessor.readBuffer(of: Int8.self, at: o))
        ?? .dpmpp2mkarras
  }
  public var batchCount: UInt32 {
    let o = _accessor.offset(VTOFFSET.batchCount.v)
    return o == 0 ? 1 : _accessor.readBuffer(of: UInt32.self, at: o)
  }
  public var batchSize: UInt32 {
    let o = _accessor.offset(VTOFFSET.batchSize.v)
    return o == 0 ? 1 : _accessor.readBuffer(of: UInt32.self, at: o)
  }
  public var hiresFix: Bool {
    let o = _accessor.offset(VTOFFSET.hiresFix.v)
    return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o)
  }
  public var hiresFixStartWidth: UInt16 {
    let o = _accessor.offset(VTOFFSET.hiresFixStartWidth.v)
    return o == 0 ? 0 : _accessor.readBuffer(of: UInt16.self, at: o)
  }
  public var hiresFixStartHeight: UInt16 {
    let o = _accessor.offset(VTOFFSET.hiresFixStartHeight.v)
    return o == 0 ? 0 : _accessor.readBuffer(of: UInt16.self, at: o)
  }
  public var hiresFixStrength: Float32 {
    let o = _accessor.offset(VTOFFSET.hiresFixStrength.v)
    return o == 0 ? 0.7 : _accessor.readBuffer(of: Float32.self, at: o)
  }
  public var upscaler: String? {
    let o = _accessor.offset(VTOFFSET.upscaler.v)
    return o == 0 ? nil : _accessor.string(at: o)
  }
  public var upscalerSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.upscaler.v) }
  public var imageGuidanceScale: Float32 {
    let o = _accessor.offset(VTOFFSET.imageGuidanceScale.v)
    return o == 0 ? 1.5 : _accessor.readBuffer(of: Float32.self, at: o)
  }
  public var seedMode: zzz_DflatGen_SeedMode {
    let o = _accessor.offset(VTOFFSET.seedMode.v)
    return o == 0
      ? .legacy
      : zzz_DflatGen_SeedMode(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .legacy
  }
  public var clipSkip: UInt32 {
    let o = _accessor.offset(VTOFFSET.clipSkip.v)
    return o == 0 ? 1 : _accessor.readBuffer(of: UInt32.self, at: o)
  }
  public var hasControls: Bool {
    let o = _accessor.offset(VTOFFSET.controls.v)
    return o == 0 ? false : true
  }
  public var controlsCount: Int32 {
    let o = _accessor.offset(VTOFFSET.controls.v)
    return o == 0 ? 0 : _accessor.vector(count: o)
  }
  public func controls(at index: Int32) -> zzz_DflatGen_Control? {
    let o = _accessor.offset(VTOFFSET.controls.v)
    return o == 0
      ? nil
      : zzz_DflatGen_Control(
        _accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4))
  }
  public var hasLoras: Bool {
    let o = _accessor.offset(VTOFFSET.loras.v)
    return o == 0 ? false : true
  }
  public var lorasCount: Int32 {
    let o = _accessor.offset(VTOFFSET.loras.v)
    return o == 0 ? 0 : _accessor.vector(count: o)
  }
  public func loras(at index: Int32) -> zzz_DflatGen_LoRA? {
    let o = _accessor.offset(VTOFFSET.loras.v)
    return o == 0
      ? nil
      : zzz_DflatGen_LoRA(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4))
  }
  public var maskBlur: Float32 {
    let o = _accessor.offset(VTOFFSET.maskBlur.v)
    return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o)
  }
  public var faceRestoration: String? {
    let o = _accessor.offset(VTOFFSET.faceRestoration.v)
    return o == 0 ? nil : _accessor.string(at: o)
  }
  public var faceRestorationSegmentArray: [UInt8]? {
    return _accessor.getVector(at: VTOFFSET.faceRestoration.v)
  }
  public var clipWeight: Float32 {
    let o = _accessor.offset(VTOFFSET.clipWeight.v)
    return o == 0 ? 1.0 : _accessor.readBuffer(of: Float32.self, at: o)
  }
  public var negativePromptForImagePrior: Bool {
    let o = _accessor.offset(VTOFFSET.negativePromptForImagePrior.v)
    return o == 0 ? true : 0 != _accessor.readBuffer(of: Byte.self, at: o)
  }
  public var imagePriorSteps: UInt32 {
    let o = _accessor.offset(VTOFFSET.imagePriorSteps.v)
    return o == 0 ? 5 : _accessor.readBuffer(of: UInt32.self, at: o)
  }
  public var refinerModel: String? {
    let o = _accessor.offset(VTOFFSET.refinerModel.v)
    return o == 0 ? nil : _accessor.string(at: o)
  }
  public var refinerModelSegmentArray: [UInt8]? {
    return _accessor.getVector(at: VTOFFSET.refinerModel.v)
  }
  public var originalImageHeight: UInt32 {
    let o = _accessor.offset(VTOFFSET.originalImageHeight.v)
    return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o)
  }
  public var originalImageWidth: UInt32 {
    let o = _accessor.offset(VTOFFSET.originalImageWidth.v)
    return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o)
  }
  public var cropTop: Int32 {
    let o = _accessor.offset(VTOFFSET.cropTop.v)
    return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o)
  }
  public var cropLeft: Int32 {
    let o = _accessor.offset(VTOFFSET.cropLeft.v)
    return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o)
  }
  public var targetImageHeight: UInt32 {
    let o = _accessor.offset(VTOFFSET.targetImageHeight.v)
    return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o)
  }
  public var targetImageWidth: UInt32 {
    let o = _accessor.offset(VTOFFSET.targetImageWidth.v)
    return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o)
  }
  public var aestheticScore: Float32 {
    let o = _accessor.offset(VTOFFSET.aestheticScore.v)
    return o == 0 ? 6.0 : _accessor.readBuffer(of: Float32.self, at: o)
  }
  public var negativeAestheticScore: Float32 {
    let o = _accessor.offset(VTOFFSET.negativeAestheticScore.v)
    return o == 0 ? 2.5 : _accessor.readBuffer(of: Float32.self, at: o)
  }
  public var zeroNegativePrompt: Bool {
    let o = _accessor.offset(VTOFFSET.zeroNegativePrompt.v)
    return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o)
  }
  public var refinerStart: Float32 {
    let o = _accessor.offset(VTOFFSET.refinerStart.v)
    return o == 0 ? 0.7 : _accessor.readBuffer(of: Float32.self, at: o)
  }
  public var negativeOriginalImageHeight: UInt32 {
    let o = _accessor.offset(VTOFFSET.negativeOriginalImageHeight.v)
    return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o)
  }
  public var negativeOriginalImageWidth: UInt32 {
    let o = _accessor.offset(VTOFFSET.negativeOriginalImageWidth.v)
    return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o)
  }
  public var name: String? {
    let o = _accessor.offset(VTOFFSET.name.v)
    return o == 0 ? nil : _accessor.string(at: o)
  }
  public var nameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.name.v) }
  public var fpsId: UInt32 {
    let o = _accessor.offset(VTOFFSET.fpsId.v)
    return o == 0 ? 5 : _accessor.readBuffer(of: UInt32.self, at: o)
  }
  public var motionBucketId: UInt32 {
    let o = _accessor.offset(VTOFFSET.motionBucketId.v)
    return o == 0 ? 127 : _accessor.readBuffer(of: UInt32.self, at: o)
  }
  public var condAug: Float32 {
    let o = _accessor.offset(VTOFFSET.condAug.v)
    return o == 0 ? 0.02 : _accessor.readBuffer(of: Float32.self, at: o)
  }
  public var startFrameCfg: Float32 {
    let o = _accessor.offset(VTOFFSET.startFrameCfg.v)
    return o == 0 ? 1.0 : _accessor.readBuffer(of: Float32.self, at: o)
  }
  public var numFrames: UInt32 {
    let o = _accessor.offset(VTOFFSET.numFrames.v)
    return o == 0 ? 14 : _accessor.readBuffer(of: UInt32.self, at: o)
  }
  public var maskBlurOutset: Int32 {
    let o = _accessor.offset(VTOFFSET.maskBlurOutset.v)
    return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o)
  }
  public var sharpness: Float32 {
    let o = _accessor.offset(VTOFFSET.sharpness.v)
    return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o)
  }
  public var shift: Float32 {
    let o = _accessor.offset(VTOFFSET.shift.v)
    return o == 0 ? 1.0 : _accessor.readBuffer(of: Float32.self, at: o)
  }
  public var stage2Steps: UInt32 {
    let o = _accessor.offset(VTOFFSET.stage2Steps.v)
    return o == 0 ? 10 : _accessor.readBuffer(of: UInt32.self, at: o)
  }
  public var stage2Cfg: Float32 {
    let o = _accessor.offset(VTOFFSET.stage2Cfg.v)
    return o == 0 ? 1.0 : _accessor.readBuffer(of: Float32.self, at: o)
  }
  public var stage2Shift: Float32 {
    let o = _accessor.offset(VTOFFSET.stage2Shift.v)
    return o == 0 ? 1.0 : _accessor.readBuffer(of: Float32.self, at: o)
  }
  public var tiledDecoding: Bool {
    let o = _accessor.offset(VTOFFSET.tiledDecoding.v)
    return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o)
  }
  public var decodingTileWidth: UInt16 {
    let o = _accessor.offset(VTOFFSET.decodingTileWidth.v)
    return o == 0 ? 10 : _accessor.readBuffer(of: UInt16.self, at: o)
  }
  public var decodingTileHeight: UInt16 {
    let o = _accessor.offset(VTOFFSET.decodingTileHeight.v)
    return o == 0 ? 10 : _accessor.readBuffer(of: UInt16.self, at: o)
  }
  public var decodingTileOverlap: UInt16 {
    let o = _accessor.offset(VTOFFSET.decodingTileOverlap.v)
    return o == 0 ? 2 : _accessor.readBuffer(of: UInt16.self, at: o)
  }
  public var stochasticSamplingGamma: Float32 {
    let o = _accessor.offset(VTOFFSET.stochasticSamplingGamma.v)
    return o == 0 ? 0.3 : _accessor.readBuffer(of: Float32.self, at: o)
  }
  public var preserveOriginalAfterInpaint: Bool {
    let o = _accessor.offset(VTOFFSET.preserveOriginalAfterInpaint.v)
    return o == 0 ? true : 0 != _accessor.readBuffer(of: Byte.self, at: o)
  }
  public var tiledDiffusion: Bool {
    let o = _accessor.offset(VTOFFSET.tiledDiffusion.v)
    return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o)
  }
  public var diffusionTileWidth: UInt16 {
    let o = _accessor.offset(VTOFFSET.diffusionTileWidth.v)
    return o == 0 ? 16 : _accessor.readBuffer(of: UInt16.self, at: o)
  }
  public var diffusionTileHeight: UInt16 {
    let o = _accessor.offset(VTOFFSET.diffusionTileHeight.v)
    return o == 0 ? 16 : _accessor.readBuffer(of: UInt16.self, at: o)
  }
  public var diffusionTileOverlap: UInt16 {
    let o = _accessor.offset(VTOFFSET.diffusionTileOverlap.v)
    return o == 0 ? 2 : _accessor.readBuffer(of: UInt16.self, at: o)
  }
  public var upscalerScaleFactor: UInt8 {
    let o = _accessor.offset(VTOFFSET.upscalerScaleFactor.v)
    return o == 0 ? 0 : _accessor.readBuffer(of: UInt8.self, at: o)
  }
  public var t5TextEncoder: Bool {
    let o = _accessor.offset(VTOFFSET.t5TextEncoder.v)
    return o == 0 ? true : 0 != _accessor.readBuffer(of: Byte.self, at: o)
  }
  public var separateClipL: Bool {
    let o = _accessor.offset(VTOFFSET.separateClipL.v)
    return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o)
  }
  public var clipLText: String? {
    let o = _accessor.offset(VTOFFSET.clipLText.v)
    return o == 0 ? nil : _accessor.string(at: o)
  }
  public var clipLTextSegmentArray: [UInt8]? {
    return _accessor.getVector(at: VTOFFSET.clipLText.v)
  }
  public var separateOpenClipG: Bool {
    let o = _accessor.offset(VTOFFSET.separateOpenClipG.v)
    return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o)
  }
  public var openClipGText: String? {
    let o = _accessor.offset(VTOFFSET.openClipGText.v)
    return o == 0 ? nil : _accessor.string(at: o)
  }
  public var openClipGTextSegmentArray: [UInt8]? {
    return _accessor.getVector(at: VTOFFSET.openClipGText.v)
  }
  public var speedUpWithGuidanceEmbed: Bool {
    let o = _accessor.offset(VTOFFSET.speedUpWithGuidanceEmbed.v)
    return o == 0 ? true : 0 != _accessor.readBuffer(of: Byte.self, at: o)
  }
  public var guidanceEmbed: Float32 {
    let o = _accessor.offset(VTOFFSET.guidanceEmbed.v)
    return o == 0 ? 3.5 : _accessor.readBuffer(of: Float32.self, at: o)
  }
  public var resolutionDependentShift: Bool {
    let o = _accessor.offset(VTOFFSET.resolutionDependentShift.v)
    return o == 0 ? true : 0 != _accessor.readBuffer(of: Byte.self, at: o)
  }
  public var teaCacheStart: Int32 {
    let o = _accessor.offset(VTOFFSET.teaCacheStart.v)
    return o == 0 ? 5 : _accessor.readBuffer(of: Int32.self, at: o)
  }
  public var teaCacheEnd: Int32 {
    let o = _accessor.offset(VTOFFSET.teaCacheEnd.v)
    return o == 0 ? -1 : _accessor.readBuffer(of: Int32.self, at: o)
  }
  public var teaCacheThreshold: Float32 {
    let o = _accessor.offset(VTOFFSET.teaCacheThreshold.v)
    return o == 0 ? 0.06 : _accessor.readBuffer(of: Float32.self, at: o)
  }
  public var teaCache: Bool {
    let o = _accessor.offset(VTOFFSET.teaCache.v)
    return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o)
  }
  public var separateT5: Bool {
    let o = _accessor.offset(VTOFFSET.separateT5.v)
    return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o)
  }
  public var t5Text: String? {
    let o = _accessor.offset(VTOFFSET.t5Text.v)
    return o == 0 ? nil : _accessor.string(at: o)
  }
  public var t5TextSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.t5Text.v) }
  public var teaCacheMaxSkipSteps: Int32 {
    let o = _accessor.offset(VTOFFSET.teaCacheMaxSkipSteps.v)
    return o == 0 ? 3 : _accessor.readBuffer(of: Int32.self, at: o)
  }
  public var causalInferenceEnabled: Bool {
    let o = _accessor.offset(VTOFFSET.causalInferenceEnabled.v)
    return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o)
  }
  public var causalInference: Int32 {
    let o = _accessor.offset(VTOFFSET.causalInference.v)
    return o == 0 ? 3 : _accessor.readBuffer(of: Int32.self, at: o)
  }
  public var causalInferencePad: Int32 {
    let o = _accessor.offset(VTOFFSET.causalInferencePad.v)
    return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o)
  }
  public var cfgZeroStar: Bool {
    let o = _accessor.offset(VTOFFSET.cfgZeroStar.v)
    return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o)
  }
  public var cfgZeroInitSteps: Int32 {
    let o = _accessor.offset(VTOFFSET.cfgZeroInitSteps.v)
    return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o)
  }
  public var compressionArtifacts: zzz_DflatGen_CompressionMethod {
    let o = _accessor.offset(VTOFFSET.compressionArtifacts.v)
    return o == 0
      ? .disabled
      : zzz_DflatGen_CompressionMethod(rawValue: _accessor.readBuffer(of: Int8.self, at: o))
        ?? .disabled
  }
  public var compressionArtifactsQuality: Float32 {
    let o = _accessor.offset(VTOFFSET.compressionArtifactsQuality.v)
    return o == 0 ? 43.1 : _accessor.readBuffer(of: Float32.self, at: o)
  }
  public static func startGenerationConfiguration(_ fbb: inout FlatBufferBuilder) -> UOffset {
    fbb.startTable(with: 86)
  }
  public static func add(id: Int64, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: id, def: 0, at: VTOFFSET.id.p)
  }
  public static func add(startWidth: UInt16, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: startWidth, def: 0, at: VTOFFSET.startWidth.p)
  }
  public static func add(startHeight: UInt16, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: startHeight, def: 0, at: VTOFFSET.startHeight.p)
  }
  public static func add(seed: UInt32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: seed, def: 0, at: VTOFFSET.seed.p)
  }
  public static func add(steps: UInt32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: steps, def: 0, at: VTOFFSET.steps.p)
  }
  public static func add(guidanceScale: Float32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: guidanceScale, def: 0.0, at: VTOFFSET.guidanceScale.p)
  }
  public static func add(strength: Float32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: strength, def: 0.0, at: VTOFFSET.strength.p)
  }
  public static func add(model: Offset, _ fbb: inout FlatBufferBuilder) {
    fbb.add(offset: model, at: VTOFFSET.model.p)
  }
  public static func add(sampler: zzz_DflatGen_SamplerType, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: sampler.rawValue, def: 0, at: VTOFFSET.sampler.p)
  }
  public static func add(batchCount: UInt32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: batchCount, def: 1, at: VTOFFSET.batchCount.p)
  }
  public static func add(batchSize: UInt32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: batchSize, def: 1, at: VTOFFSET.batchSize.p)
  }
  public static func add(hiresFix: Bool, _ fbb: inout FlatBufferBuilder) {
    fbb.add(
      element: hiresFix, def: false,
      at: VTOFFSET.hiresFix.p)
  }
  public static func add(hiresFixStartWidth: UInt16, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: hiresFixStartWidth, def: 0, at: VTOFFSET.hiresFixStartWidth.p)
  }
  public static func add(hiresFixStartHeight: UInt16, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: hiresFixStartHeight, def: 0, at: VTOFFSET.hiresFixStartHeight.p)
  }
  public static func add(hiresFixStrength: Float32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: hiresFixStrength, def: 0.7, at: VTOFFSET.hiresFixStrength.p)
  }
  public static func add(upscaler: Offset, _ fbb: inout FlatBufferBuilder) {
    fbb.add(offset: upscaler, at: VTOFFSET.upscaler.p)
  }
  public static func add(imageGuidanceScale: Float32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: imageGuidanceScale, def: 1.5, at: VTOFFSET.imageGuidanceScale.p)
  }
  public static func add(seedMode: zzz_DflatGen_SeedMode, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: seedMode.rawValue, def: 0, at: VTOFFSET.seedMode.p)
  }
  public static func add(clipSkip: UInt32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: clipSkip, def: 1, at: VTOFFSET.clipSkip.p)
  }
  public static func addVectorOf(controls: Offset, _ fbb: inout FlatBufferBuilder) {
    fbb.add(offset: controls, at: VTOFFSET.controls.p)
  }
  public static func addVectorOf(loras: Offset, _ fbb: inout FlatBufferBuilder) {
    fbb.add(offset: loras, at: VTOFFSET.loras.p)
  }
  public static func add(maskBlur: Float32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: maskBlur, def: 0.0, at: VTOFFSET.maskBlur.p)
  }
  public static func add(faceRestoration: Offset, _ fbb: inout FlatBufferBuilder) {
    fbb.add(offset: faceRestoration, at: VTOFFSET.faceRestoration.p)
  }
  public static func add(clipWeight: Float32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: clipWeight, def: 1.0, at: VTOFFSET.clipWeight.p)
  }
  public static func add(negativePromptForImagePrior: Bool, _ fbb: inout FlatBufferBuilder) {
    fbb.add(
      element: negativePromptForImagePrior, def: true,
      at: VTOFFSET.negativePromptForImagePrior.p)
  }
  public static func add(imagePriorSteps: UInt32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: imagePriorSteps, def: 5, at: VTOFFSET.imagePriorSteps.p)
  }
  public static func add(refinerModel: Offset, _ fbb: inout FlatBufferBuilder) {
    fbb.add(offset: refinerModel, at: VTOFFSET.refinerModel.p)
  }
  public static func add(originalImageHeight: UInt32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: originalImageHeight, def: 0, at: VTOFFSET.originalImageHeight.p)
  }
  public static func add(originalImageWidth: UInt32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: originalImageWidth, def: 0, at: VTOFFSET.originalImageWidth.p)
  }
  public static func add(cropTop: Int32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: cropTop, def: 0, at: VTOFFSET.cropTop.p)
  }
  public static func add(cropLeft: Int32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: cropLeft, def: 0, at: VTOFFSET.cropLeft.p)
  }
  public static func add(targetImageHeight: UInt32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: targetImageHeight, def: 0, at: VTOFFSET.targetImageHeight.p)
  }
  public static func add(targetImageWidth: UInt32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: targetImageWidth, def: 0, at: VTOFFSET.targetImageWidth.p)
  }
  public static func add(aestheticScore: Float32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: aestheticScore, def: 6.0, at: VTOFFSET.aestheticScore.p)
  }
  public static func add(negativeAestheticScore: Float32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: negativeAestheticScore, def: 2.5, at: VTOFFSET.negativeAestheticScore.p)
  }
  public static func add(zeroNegativePrompt: Bool, _ fbb: inout FlatBufferBuilder) {
    fbb.add(
      element: zeroNegativePrompt, def: false,
      at: VTOFFSET.zeroNegativePrompt.p)
  }
  public static func add(refinerStart: Float32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: refinerStart, def: 0.7, at: VTOFFSET.refinerStart.p)
  }
  public static func add(negativeOriginalImageHeight: UInt32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(
      element: negativeOriginalImageHeight, def: 0, at: VTOFFSET.negativeOriginalImageHeight.p)
  }
  public static func add(negativeOriginalImageWidth: UInt32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: negativeOriginalImageWidth, def: 0, at: VTOFFSET.negativeOriginalImageWidth.p)
  }
  public static func add(name: Offset, _ fbb: inout FlatBufferBuilder) {
    fbb.add(offset: name, at: VTOFFSET.name.p)
  }
  public static func add(fpsId: UInt32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: fpsId, def: 5, at: VTOFFSET.fpsId.p)
  }
  public static func add(motionBucketId: UInt32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: motionBucketId, def: 127, at: VTOFFSET.motionBucketId.p)
  }
  public static func add(condAug: Float32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: condAug, def: 0.02, at: VTOFFSET.condAug.p)
  }
  public static func add(startFrameCfg: Float32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: startFrameCfg, def: 1.0, at: VTOFFSET.startFrameCfg.p)
  }
  public static func add(numFrames: UInt32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: numFrames, def: 14, at: VTOFFSET.numFrames.p)
  }
  public static func add(maskBlurOutset: Int32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: maskBlurOutset, def: 0, at: VTOFFSET.maskBlurOutset.p)
  }
  public static func add(sharpness: Float32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: sharpness, def: 0.0, at: VTOFFSET.sharpness.p)
  }
  public static func add(shift: Float32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: shift, def: 1.0, at: VTOFFSET.shift.p)
  }
  public static func add(stage2Steps: UInt32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: stage2Steps, def: 10, at: VTOFFSET.stage2Steps.p)
  }
  public static func add(stage2Cfg: Float32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: stage2Cfg, def: 1.0, at: VTOFFSET.stage2Cfg.p)
  }
  public static func add(stage2Shift: Float32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: stage2Shift, def: 1.0, at: VTOFFSET.stage2Shift.p)
  }
  public static func add(tiledDecoding: Bool, _ fbb: inout FlatBufferBuilder) {
    fbb.add(
      element: tiledDecoding, def: false,
      at: VTOFFSET.tiledDecoding.p)
  }
  public static func add(decodingTileWidth: UInt16, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: decodingTileWidth, def: 10, at: VTOFFSET.decodingTileWidth.p)
  }
  public static func add(decodingTileHeight: UInt16, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: decodingTileHeight, def: 10, at: VTOFFSET.decodingTileHeight.p)
  }
  public static func add(decodingTileOverlap: UInt16, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: decodingTileOverlap, def: 2, at: VTOFFSET.decodingTileOverlap.p)
  }
  public static func add(stochasticSamplingGamma: Float32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: stochasticSamplingGamma, def: 0.3, at: VTOFFSET.stochasticSamplingGamma.p)
  }
  public static func add(preserveOriginalAfterInpaint: Bool, _ fbb: inout FlatBufferBuilder) {
    fbb.add(
      element: preserveOriginalAfterInpaint, def: true,
      at: VTOFFSET.preserveOriginalAfterInpaint.p)
  }
  public static func add(tiledDiffusion: Bool, _ fbb: inout FlatBufferBuilder) {
    fbb.add(
      element: tiledDiffusion, def: false,
      at: VTOFFSET.tiledDiffusion.p)
  }
  public static func add(diffusionTileWidth: UInt16, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: diffusionTileWidth, def: 16, at: VTOFFSET.diffusionTileWidth.p)
  }
  public static func add(diffusionTileHeight: UInt16, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: diffusionTileHeight, def: 16, at: VTOFFSET.diffusionTileHeight.p)
  }
  public static func add(diffusionTileOverlap: UInt16, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: diffusionTileOverlap, def: 2, at: VTOFFSET.diffusionTileOverlap.p)
  }
  public static func add(upscalerScaleFactor: UInt8, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: upscalerScaleFactor, def: 0, at: VTOFFSET.upscalerScaleFactor.p)
  }
  public static func add(t5TextEncoder: Bool, _ fbb: inout FlatBufferBuilder) {
    fbb.add(
      element: t5TextEncoder, def: true,
      at: VTOFFSET.t5TextEncoder.p)
  }
  public static func add(separateClipL: Bool, _ fbb: inout FlatBufferBuilder) {
    fbb.add(
      element: separateClipL, def: false,
      at: VTOFFSET.separateClipL.p)
  }
  public static func add(clipLText: Offset, _ fbb: inout FlatBufferBuilder) {
    fbb.add(offset: clipLText, at: VTOFFSET.clipLText.p)
  }
  public static func add(separateOpenClipG: Bool, _ fbb: inout FlatBufferBuilder) {
    fbb.add(
      element: separateOpenClipG, def: false,
      at: VTOFFSET.separateOpenClipG.p)
  }
  public static func add(openClipGText: Offset, _ fbb: inout FlatBufferBuilder) {
    fbb.add(offset: openClipGText, at: VTOFFSET.openClipGText.p)
  }
  public static func add(speedUpWithGuidanceEmbed: Bool, _ fbb: inout FlatBufferBuilder) {
    fbb.add(
      element: speedUpWithGuidanceEmbed, def: true,
      at: VTOFFSET.speedUpWithGuidanceEmbed.p)
  }
  public static func add(guidanceEmbed: Float32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: guidanceEmbed, def: 3.5, at: VTOFFSET.guidanceEmbed.p)
  }
  public static func add(resolutionDependentShift: Bool, _ fbb: inout FlatBufferBuilder) {
    fbb.add(
      element: resolutionDependentShift, def: true,
      at: VTOFFSET.resolutionDependentShift.p)
  }
  public static func add(teaCacheStart: Int32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: teaCacheStart, def: 5, at: VTOFFSET.teaCacheStart.p)
  }
  public static func add(teaCacheEnd: Int32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: teaCacheEnd, def: -1, at: VTOFFSET.teaCacheEnd.p)
  }
  public static func add(teaCacheThreshold: Float32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: teaCacheThreshold, def: 0.06, at: VTOFFSET.teaCacheThreshold.p)
  }
  public static func add(teaCache: Bool, _ fbb: inout FlatBufferBuilder) {
    fbb.add(
      element: teaCache, def: false,
      at: VTOFFSET.teaCache.p)
  }
  public static func add(separateT5: Bool, _ fbb: inout FlatBufferBuilder) {
    fbb.add(
      element: separateT5, def: false,
      at: VTOFFSET.separateT5.p)
  }
  public static func add(t5Text: Offset, _ fbb: inout FlatBufferBuilder) {
    fbb.add(offset: t5Text, at: VTOFFSET.t5Text.p)
  }
  public static func add(teaCacheMaxSkipSteps: Int32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: teaCacheMaxSkipSteps, def: 3, at: VTOFFSET.teaCacheMaxSkipSteps.p)
  }
  public static func add(causalInferenceEnabled: Bool, _ fbb: inout FlatBufferBuilder) {
    fbb.add(
      element: causalInferenceEnabled, def: false,
      at: VTOFFSET.causalInferenceEnabled.p)
  }
  public static func add(causalInference: Int32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: causalInference, def: 3, at: VTOFFSET.causalInference.p)
  }
  public static func add(causalInferencePad: Int32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: causalInferencePad, def: 0, at: VTOFFSET.causalInferencePad.p)
  }
  public static func add(cfgZeroStar: Bool, _ fbb: inout FlatBufferBuilder) {
    fbb.add(
      element: cfgZeroStar, def: false,
      at: VTOFFSET.cfgZeroStar.p)
  }
  public static func add(cfgZeroInitSteps: Int32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: cfgZeroInitSteps, def: 0, at: VTOFFSET.cfgZeroInitSteps.p)
  }
  public static func add(
    compressionArtifacts: zzz_DflatGen_CompressionMethod, _ fbb: inout FlatBufferBuilder
  ) { fbb.add(element: compressionArtifacts.rawValue, def: 0, at: VTOFFSET.compressionArtifacts.p) }
  public static func add(compressionArtifactsQuality: Float32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(
      element: compressionArtifactsQuality, def: 43.1, at: VTOFFSET.compressionArtifactsQuality.p)
  }
  public static func endGenerationConfiguration(_ fbb: inout FlatBufferBuilder, start: UOffset)
    -> Offset
  {
    let end = Offset(offset: fbb.endTable(at: start))
    return end
  }
  public static func createGenerationConfiguration(
    _ fbb: inout FlatBufferBuilder,
    id: Int64 = 0,
    startWidth: UInt16 = 0,
    startHeight: UInt16 = 0,
    seed: UInt32 = 0,
    steps: UInt32 = 0,
    guidanceScale: Float32 = 0.0,
    strength: Float32 = 0.0,
    modelOffset model: Offset = Offset(),
    sampler: zzz_DflatGen_SamplerType = .dpmpp2mkarras,
    batchCount: UInt32 = 1,
    batchSize: UInt32 = 1,
    hiresFix: Bool = false,
    hiresFixStartWidth: UInt16 = 0,
    hiresFixStartHeight: UInt16 = 0,
    hiresFixStrength: Float32 = 0.7,
    upscalerOffset upscaler: Offset = Offset(),
    imageGuidanceScale: Float32 = 1.5,
    seedMode: zzz_DflatGen_SeedMode = .legacy,
    clipSkip: UInt32 = 1,
    controlsVectorOffset controls: Offset = Offset(),
    lorasVectorOffset loras: Offset = Offset(),
    maskBlur: Float32 = 0.0,
    faceRestorationOffset faceRestoration: Offset = Offset(),
    clipWeight: Float32 = 1.0,
    negativePromptForImagePrior: Bool = true,
    imagePriorSteps: UInt32 = 5,
    refinerModelOffset refinerModel: Offset = Offset(),
    originalImageHeight: UInt32 = 0,
    originalImageWidth: UInt32 = 0,
    cropTop: Int32 = 0,
    cropLeft: Int32 = 0,
    targetImageHeight: UInt32 = 0,
    targetImageWidth: UInt32 = 0,
    aestheticScore: Float32 = 6.0,
    negativeAestheticScore: Float32 = 2.5,
    zeroNegativePrompt: Bool = false,
    refinerStart: Float32 = 0.7,
    negativeOriginalImageHeight: UInt32 = 0,
    negativeOriginalImageWidth: UInt32 = 0,
    nameOffset name: Offset = Offset(),
    fpsId: UInt32 = 5,
    motionBucketId: UInt32 = 127,
    condAug: Float32 = 0.02,
    startFrameCfg: Float32 = 1.0,
    numFrames: UInt32 = 14,
    maskBlurOutset: Int32 = 0,
    sharpness: Float32 = 0.0,
    shift: Float32 = 1.0,
    stage2Steps: UInt32 = 10,
    stage2Cfg: Float32 = 1.0,
    stage2Shift: Float32 = 1.0,
    tiledDecoding: Bool = false,
    decodingTileWidth: UInt16 = 10,
    decodingTileHeight: UInt16 = 10,
    decodingTileOverlap: UInt16 = 2,
    stochasticSamplingGamma: Float32 = 0.3,
    preserveOriginalAfterInpaint: Bool = true,
    tiledDiffusion: Bool = false,
    diffusionTileWidth: UInt16 = 16,
    diffusionTileHeight: UInt16 = 16,
    diffusionTileOverlap: UInt16 = 2,
    upscalerScaleFactor: UInt8 = 0,
    t5TextEncoder: Bool = true,
    separateClipL: Bool = false,
    clipLTextOffset clipLText: Offset = Offset(),
    separateOpenClipG: Bool = false,
    openClipGTextOffset openClipGText: Offset = Offset(),
    speedUpWithGuidanceEmbed: Bool = true,
    guidanceEmbed: Float32 = 3.5,
    resolutionDependentShift: Bool = true,
    teaCacheStart: Int32 = 5,
    teaCacheEnd: Int32 = -1,
    teaCacheThreshold: Float32 = 0.06,
    teaCache: Bool = false,
    separateT5: Bool = false,
    t5TextOffset t5Text: Offset = Offset(),
    teaCacheMaxSkipSteps: Int32 = 3,
    causalInferenceEnabled: Bool = false,
    causalInference: Int32 = 3,
    causalInferencePad: Int32 = 0,
    cfgZeroStar: Bool = false,
    cfgZeroInitSteps: Int32 = 0,
    compressionArtifacts: zzz_DflatGen_CompressionMethod = .disabled,
    compressionArtifactsQuality: Float32 = 43.1
  ) -> Offset {
    let __start = zzz_DflatGen_GenerationConfiguration.startGenerationConfiguration(&fbb)
    zzz_DflatGen_GenerationConfiguration.add(id: id, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(startWidth: startWidth, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(startHeight: startHeight, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(seed: seed, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(steps: steps, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(guidanceScale: guidanceScale, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(strength: strength, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(model: model, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(sampler: sampler, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(batchCount: batchCount, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(batchSize: batchSize, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(hiresFix: hiresFix, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(hiresFixStartWidth: hiresFixStartWidth, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(hiresFixStartHeight: hiresFixStartHeight, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(hiresFixStrength: hiresFixStrength, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(upscaler: upscaler, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(imageGuidanceScale: imageGuidanceScale, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(seedMode: seedMode, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(clipSkip: clipSkip, &fbb)
    zzz_DflatGen_GenerationConfiguration.addVectorOf(controls: controls, &fbb)
    zzz_DflatGen_GenerationConfiguration.addVectorOf(loras: loras, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(maskBlur: maskBlur, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(faceRestoration: faceRestoration, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(clipWeight: clipWeight, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(
      negativePromptForImagePrior: negativePromptForImagePrior, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(imagePriorSteps: imagePriorSteps, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(refinerModel: refinerModel, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(originalImageHeight: originalImageHeight, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(originalImageWidth: originalImageWidth, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(cropTop: cropTop, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(cropLeft: cropLeft, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(targetImageHeight: targetImageHeight, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(targetImageWidth: targetImageWidth, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(aestheticScore: aestheticScore, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(negativeAestheticScore: negativeAestheticScore, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(zeroNegativePrompt: zeroNegativePrompt, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(refinerStart: refinerStart, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(
      negativeOriginalImageHeight: negativeOriginalImageHeight, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(
      negativeOriginalImageWidth: negativeOriginalImageWidth, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(name: name, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(fpsId: fpsId, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(motionBucketId: motionBucketId, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(condAug: condAug, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(startFrameCfg: startFrameCfg, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(numFrames: numFrames, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(maskBlurOutset: maskBlurOutset, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(sharpness: sharpness, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(shift: shift, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(stage2Steps: stage2Steps, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(stage2Cfg: stage2Cfg, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(stage2Shift: stage2Shift, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(tiledDecoding: tiledDecoding, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(decodingTileWidth: decodingTileWidth, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(decodingTileHeight: decodingTileHeight, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(decodingTileOverlap: decodingTileOverlap, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(stochasticSamplingGamma: stochasticSamplingGamma, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(
      preserveOriginalAfterInpaint: preserveOriginalAfterInpaint, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(tiledDiffusion: tiledDiffusion, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(diffusionTileWidth: diffusionTileWidth, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(diffusionTileHeight: diffusionTileHeight, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(diffusionTileOverlap: diffusionTileOverlap, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(upscalerScaleFactor: upscalerScaleFactor, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(t5TextEncoder: t5TextEncoder, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(separateClipL: separateClipL, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(clipLText: clipLText, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(separateOpenClipG: separateOpenClipG, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(openClipGText: openClipGText, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(
      speedUpWithGuidanceEmbed: speedUpWithGuidanceEmbed, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(guidanceEmbed: guidanceEmbed, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(
      resolutionDependentShift: resolutionDependentShift, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(teaCacheStart: teaCacheStart, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(teaCacheEnd: teaCacheEnd, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(teaCacheThreshold: teaCacheThreshold, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(teaCache: teaCache, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(separateT5: separateT5, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(t5Text: t5Text, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(teaCacheMaxSkipSteps: teaCacheMaxSkipSteps, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(causalInferenceEnabled: causalInferenceEnabled, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(causalInference: causalInference, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(causalInferencePad: causalInferencePad, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(cfgZeroStar: cfgZeroStar, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(cfgZeroInitSteps: cfgZeroInitSteps, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(compressionArtifacts: compressionArtifacts, &fbb)
    zzz_DflatGen_GenerationConfiguration.add(
      compressionArtifactsQuality: compressionArtifactsQuality, &fbb)
    return zzz_DflatGen_GenerationConfiguration.endGenerationConfiguration(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws
  where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.id.p, fieldName: "id", required: false, type: Int64.self)
    try _v.visit(
      field: VTOFFSET.startWidth.p, fieldName: "startWidth", required: false, type: UInt16.self)
    try _v.visit(
      field: VTOFFSET.startHeight.p, fieldName: "startHeight", required: false, type: UInt16.self)
    try _v.visit(field: VTOFFSET.seed.p, fieldName: "seed", required: false, type: UInt32.self)
    try _v.visit(field: VTOFFSET.steps.p, fieldName: "steps", required: false, type: UInt32.self)
    try _v.visit(
      field: VTOFFSET.guidanceScale.p, fieldName: "guidanceScale", required: false,
      type: Float32.self)
    try _v.visit(
      field: VTOFFSET.strength.p, fieldName: "strength", required: false, type: Float32.self)
    try _v.visit(
      field: VTOFFSET.model.p, fieldName: "model", required: false, type: ForwardOffset<String>.self
    )
    try _v.visit(
      field: VTOFFSET.sampler.p, fieldName: "sampler", required: false,
      type: zzz_DflatGen_SamplerType.self)
    try _v.visit(
      field: VTOFFSET.batchCount.p, fieldName: "batchCount", required: false, type: UInt32.self)
    try _v.visit(
      field: VTOFFSET.batchSize.p, fieldName: "batchSize", required: false, type: UInt32.self)
    try _v.visit(
      field: VTOFFSET.hiresFix.p, fieldName: "hiresFix", required: false, type: Bool.self)
    try _v.visit(
      field: VTOFFSET.hiresFixStartWidth.p, fieldName: "hiresFixStartWidth", required: false,
      type: UInt16.self)
    try _v.visit(
      field: VTOFFSET.hiresFixStartHeight.p, fieldName: "hiresFixStartHeight", required: false,
      type: UInt16.self)
    try _v.visit(
      field: VTOFFSET.hiresFixStrength.p, fieldName: "hiresFixStrength", required: false,
      type: Float32.self)
    try _v.visit(
      field: VTOFFSET.upscaler.p, fieldName: "upscaler", required: false,
      type: ForwardOffset<String>.self)
    try _v.visit(
      field: VTOFFSET.imageGuidanceScale.p, fieldName: "imageGuidanceScale", required: false,
      type: Float32.self)
    try _v.visit(
      field: VTOFFSET.seedMode.p, fieldName: "seedMode", required: false,
      type: zzz_DflatGen_SeedMode.self)
    try _v.visit(
      field: VTOFFSET.clipSkip.p, fieldName: "clipSkip", required: false, type: UInt32.self)
    try _v.visit(
      field: VTOFFSET.controls.p, fieldName: "controls", required: false,
      type: ForwardOffset<Vector<ForwardOffset<zzz_DflatGen_Control>, zzz_DflatGen_Control>>.self)
    try _v.visit(
      field: VTOFFSET.loras.p, fieldName: "loras", required: false,
      type: ForwardOffset<Vector<ForwardOffset<zzz_DflatGen_LoRA>, zzz_DflatGen_LoRA>>.self)
    try _v.visit(
      field: VTOFFSET.maskBlur.p, fieldName: "maskBlur", required: false, type: Float32.self)
    try _v.visit(
      field: VTOFFSET.faceRestoration.p, fieldName: "faceRestoration", required: false,
      type: ForwardOffset<String>.self)
    try _v.visit(
      field: VTOFFSET.clipWeight.p, fieldName: "clipWeight", required: false, type: Float32.self)
    try _v.visit(
      field: VTOFFSET.negativePromptForImagePrior.p, fieldName: "negativePromptForImagePrior",
      required: false, type: Bool.self)
    try _v.visit(
      field: VTOFFSET.imagePriorSteps.p, fieldName: "imagePriorSteps", required: false,
      type: UInt32.self)
    try _v.visit(
      field: VTOFFSET.refinerModel.p, fieldName: "refinerModel", required: false,
      type: ForwardOffset<String>.self)
    try _v.visit(
      field: VTOFFSET.originalImageHeight.p, fieldName: "originalImageHeight", required: false,
      type: UInt32.self)
    try _v.visit(
      field: VTOFFSET.originalImageWidth.p, fieldName: "originalImageWidth", required: false,
      type: UInt32.self)
    try _v.visit(field: VTOFFSET.cropTop.p, fieldName: "cropTop", required: false, type: Int32.self)
    try _v.visit(
      field: VTOFFSET.cropLeft.p, fieldName: "cropLeft", required: false, type: Int32.self)
    try _v.visit(
      field: VTOFFSET.targetImageHeight.p, fieldName: "targetImageHeight", required: false,
      type: UInt32.self)
    try _v.visit(
      field: VTOFFSET.targetImageWidth.p, fieldName: "targetImageWidth", required: false,
      type: UInt32.self)
    try _v.visit(
      field: VTOFFSET.aestheticScore.p, fieldName: "aestheticScore", required: false,
      type: Float32.self)
    try _v.visit(
      field: VTOFFSET.negativeAestheticScore.p, fieldName: "negativeAestheticScore",
      required: false, type: Float32.self)
    try _v.visit(
      field: VTOFFSET.zeroNegativePrompt.p, fieldName: "zeroNegativePrompt", required: false,
      type: Bool.self)
    try _v.visit(
      field: VTOFFSET.refinerStart.p, fieldName: "refinerStart", required: false, type: Float32.self
    )
    try _v.visit(
      field: VTOFFSET.negativeOriginalImageHeight.p, fieldName: "negativeOriginalImageHeight",
      required: false, type: UInt32.self)
    try _v.visit(
      field: VTOFFSET.negativeOriginalImageWidth.p, fieldName: "negativeOriginalImageWidth",
      required: false, type: UInt32.self)
    try _v.visit(
      field: VTOFFSET.name.p, fieldName: "name", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.fpsId.p, fieldName: "fpsId", required: false, type: UInt32.self)
    try _v.visit(
      field: VTOFFSET.motionBucketId.p, fieldName: "motionBucketId", required: false,
      type: UInt32.self)
    try _v.visit(
      field: VTOFFSET.condAug.p, fieldName: "condAug", required: false, type: Float32.self)
    try _v.visit(
      field: VTOFFSET.startFrameCfg.p, fieldName: "startFrameCfg", required: false,
      type: Float32.self)
    try _v.visit(
      field: VTOFFSET.numFrames.p, fieldName: "numFrames", required: false, type: UInt32.self)
    try _v.visit(
      field: VTOFFSET.maskBlurOutset.p, fieldName: "maskBlurOutset", required: false,
      type: Int32.self)
    try _v.visit(
      field: VTOFFSET.sharpness.p, fieldName: "sharpness", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.shift.p, fieldName: "shift", required: false, type: Float32.self)
    try _v.visit(
      field: VTOFFSET.stage2Steps.p, fieldName: "stage2Steps", required: false, type: UInt32.self)
    try _v.visit(
      field: VTOFFSET.stage2Cfg.p, fieldName: "stage2Cfg", required: false, type: Float32.self)
    try _v.visit(
      field: VTOFFSET.stage2Shift.p, fieldName: "stage2Shift", required: false, type: Float32.self)
    try _v.visit(
      field: VTOFFSET.tiledDecoding.p, fieldName: "tiledDecoding", required: false, type: Bool.self)
    try _v.visit(
      field: VTOFFSET.decodingTileWidth.p, fieldName: "decodingTileWidth", required: false,
      type: UInt16.self)
    try _v.visit(
      field: VTOFFSET.decodingTileHeight.p, fieldName: "decodingTileHeight", required: false,
      type: UInt16.self)
    try _v.visit(
      field: VTOFFSET.decodingTileOverlap.p, fieldName: "decodingTileOverlap", required: false,
      type: UInt16.self)
    try _v.visit(
      field: VTOFFSET.stochasticSamplingGamma.p, fieldName: "stochasticSamplingGamma",
      required: false, type: Float32.self)
    try _v.visit(
      field: VTOFFSET.preserveOriginalAfterInpaint.p, fieldName: "preserveOriginalAfterInpaint",
      required: false, type: Bool.self)
    try _v.visit(
      field: VTOFFSET.tiledDiffusion.p, fieldName: "tiledDiffusion", required: false,
      type: Bool.self)
    try _v.visit(
      field: VTOFFSET.diffusionTileWidth.p, fieldName: "diffusionTileWidth", required: false,
      type: UInt16.self)
    try _v.visit(
      field: VTOFFSET.diffusionTileHeight.p, fieldName: "diffusionTileHeight", required: false,
      type: UInt16.self)
    try _v.visit(
      field: VTOFFSET.diffusionTileOverlap.p, fieldName: "diffusionTileOverlap", required: false,
      type: UInt16.self)
    try _v.visit(
      field: VTOFFSET.upscalerScaleFactor.p, fieldName: "upscalerScaleFactor", required: false,
      type: UInt8.self)
    try _v.visit(
      field: VTOFFSET.t5TextEncoder.p, fieldName: "t5TextEncoder", required: false, type: Bool.self)
    try _v.visit(
      field: VTOFFSET.separateClipL.p, fieldName: "separateClipL", required: false, type: Bool.self)
    try _v.visit(
      field: VTOFFSET.clipLText.p, fieldName: "clipLText", required: false,
      type: ForwardOffset<String>.self)
    try _v.visit(
      field: VTOFFSET.separateOpenClipG.p, fieldName: "separateOpenClipG", required: false,
      type: Bool.self)
    try _v.visit(
      field: VTOFFSET.openClipGText.p, fieldName: "openClipGText", required: false,
      type: ForwardOffset<String>.self)
    try _v.visit(
      field: VTOFFSET.speedUpWithGuidanceEmbed.p, fieldName: "speedUpWithGuidanceEmbed",
      required: false, type: Bool.self)
    try _v.visit(
      field: VTOFFSET.guidanceEmbed.p, fieldName: "guidanceEmbed", required: false,
      type: Float32.self)
    try _v.visit(
      field: VTOFFSET.resolutionDependentShift.p, fieldName: "resolutionDependentShift",
      required: false, type: Bool.self)
    try _v.visit(
      field: VTOFFSET.teaCacheStart.p, fieldName: "teaCacheStart", required: false, type: Int32.self
    )
    try _v.visit(
      field: VTOFFSET.teaCacheEnd.p, fieldName: "teaCacheEnd", required: false, type: Int32.self)
    try _v.visit(
      field: VTOFFSET.teaCacheThreshold.p, fieldName: "teaCacheThreshold", required: false,
      type: Float32.self)
    try _v.visit(
      field: VTOFFSET.teaCache.p, fieldName: "teaCache", required: false, type: Bool.self)
    try _v.visit(
      field: VTOFFSET.separateT5.p, fieldName: "separateT5", required: false, type: Bool.self)
    try _v.visit(
      field: VTOFFSET.t5Text.p, fieldName: "t5Text", required: false,
      type: ForwardOffset<String>.self)
    try _v.visit(
      field: VTOFFSET.teaCacheMaxSkipSteps.p, fieldName: "teaCacheMaxSkipSteps", required: false,
      type: Int32.self)
    try _v.visit(
      field: VTOFFSET.causalInferenceEnabled.p, fieldName: "causalInferenceEnabled",
      required: false, type: Bool.self)
    try _v.visit(
      field: VTOFFSET.causalInference.p, fieldName: "causalInference", required: false,
      type: Int32.self)
    try _v.visit(
      field: VTOFFSET.causalInferencePad.p, fieldName: "causalInferencePad", required: false,
      type: Int32.self)
    try _v.visit(
      field: VTOFFSET.cfgZeroStar.p, fieldName: "cfgZeroStar", required: false, type: Bool.self)
    try _v.visit(
      field: VTOFFSET.cfgZeroInitSteps.p, fieldName: "cfgZeroInitSteps", required: false,
      type: Int32.self)
    try _v.visit(
      field: VTOFFSET.compressionArtifacts.p, fieldName: "compressionArtifacts", required: false,
      type: zzz_DflatGen_CompressionMethod.self)
    try _v.visit(
      field: VTOFFSET.compressionArtifactsQuality.p, fieldName: "compressionArtifactsQuality",
      required: false, type: Float32.self)
    _v.finish()
  }
}
