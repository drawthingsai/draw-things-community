// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public enum zzz_DflatGen_LoRATrainableLayer: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case latentsembedder = 0
  case contextembedder = 1
  case projectout = 2
  case qkv = 3
  case qkvcontext = 4
  case out = 5
  case outcontext = 6
  case feedforward = 7
  case feedforwardcontext = 8

  public static var max: zzz_DflatGen_LoRATrainableLayer { return .feedforwardcontext }
  public static var min: zzz_DflatGen_LoRATrainableLayer { return .latentsembedder }
}

public struct zzz_DflatGen_LoRATrainingConfiguration: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_22_9_29() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static func getRootAsLoRATrainingConfiguration(bb: ByteBuffer)
    -> zzz_DflatGen_LoRATrainingConfiguration
  {
    return zzz_DflatGen_LoRATrainingConfiguration(
      Table(
        bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))
    )
  }

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case id = 4
    case name = 6
    case startWidth = 8
    case startHeight = 10
    case seed = 12
    case trainingSteps = 14
    case baseModel = 16
    case networkDim = 18
    case networkScale = 20
    case unetLearningRate = 22
    case saveEveryNSteps = 24
    case warmupSteps = 26
    case gradientAccumulationSteps = 28
    case cotrainTextModel = 30
    case textModelLearningRate = 32
    case clipSkip = 34
    case noiseOffset = 36
    case denoisingStart = 38
    case denoisingEnd = 40
    case triggerWord = 42
    case autoFillPrompt = 44
    case autoCaptioning = 46
    case cotrainCustomEmbedding = 48
    case customEmbeddingLearningRate = 50
    case customEmbeddingLength = 52
    case stopEmbeddingTrainingAtStep = 54
    case trainableLayers = 56
    case layerIndices = 58
    case shift = 60
    case resolutionDependentShift = 62
    case guidanceEmbedLowerBound = 64
    case guidanceEmbedUpperBound = 66
    case unetLearningRateLowerBound = 68
    case stepsBetweenRestarts = 70
    case captionDropoutRate = 72
    case orthonormalLoraDown = 74
    case maxTextLength = 76
    case useImageAspectRatio = 78
    case additionalScales = 80
    case powerEmaLowerBound = 82
    case powerEmaUpperBound = 84
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var id: Int64 {
    let o = _accessor.offset(VTOFFSET.id.v)
    return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o)
  }
  public var name: String? {
    let o = _accessor.offset(VTOFFSET.name.v)
    return o == 0 ? nil : _accessor.string(at: o)
  }
  public var nameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.name.v) }
  public var startWidth: UInt16 {
    let o = _accessor.offset(VTOFFSET.startWidth.v)
    return o == 0 ? 0 : _accessor.readBuffer(of: UInt16.self, at: o)
  }
  public var startHeight: UInt16 {
    let o = _accessor.offset(VTOFFSET.startHeight.v)
    return o == 0 ? 0 : _accessor.readBuffer(of: UInt16.self, at: o)
  }
  public var seed: UInt32 {
    let o = _accessor.offset(VTOFFSET.seed.v)
    return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o)
  }
  public var trainingSteps: UInt32 {
    let o = _accessor.offset(VTOFFSET.trainingSteps.v)
    return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o)
  }
  public var baseModel: String? {
    let o = _accessor.offset(VTOFFSET.baseModel.v)
    return o == 0 ? nil : _accessor.string(at: o)
  }
  public var baseModelSegmentArray: [UInt8]? {
    return _accessor.getVector(at: VTOFFSET.baseModel.v)
  }
  public var networkDim: UInt16 {
    let o = _accessor.offset(VTOFFSET.networkDim.v)
    return o == 0 ? 0 : _accessor.readBuffer(of: UInt16.self, at: o)
  }
  public var networkScale: Float32 {
    let o = _accessor.offset(VTOFFSET.networkScale.v)
    return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o)
  }
  public var unetLearningRate: Float32 {
    let o = _accessor.offset(VTOFFSET.unetLearningRate.v)
    return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o)
  }
  public var saveEveryNSteps: UInt32 {
    let o = _accessor.offset(VTOFFSET.saveEveryNSteps.v)
    return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o)
  }
  public var warmupSteps: UInt32 {
    let o = _accessor.offset(VTOFFSET.warmupSteps.v)
    return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o)
  }
  public var gradientAccumulationSteps: UInt32 {
    let o = _accessor.offset(VTOFFSET.gradientAccumulationSteps.v)
    return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o)
  }
  public var cotrainTextModel: Bool {
    let o = _accessor.offset(VTOFFSET.cotrainTextModel.v)
    return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o)
  }
  public var textModelLearningRate: Float32 {
    let o = _accessor.offset(VTOFFSET.textModelLearningRate.v)
    return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o)
  }
  public var clipSkip: UInt32 {
    let o = _accessor.offset(VTOFFSET.clipSkip.v)
    return o == 0 ? 1 : _accessor.readBuffer(of: UInt32.self, at: o)
  }
  public var noiseOffset: Float32 {
    let o = _accessor.offset(VTOFFSET.noiseOffset.v)
    return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o)
  }
  public var denoisingStart: Float32 {
    let o = _accessor.offset(VTOFFSET.denoisingStart.v)
    return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o)
  }
  public var denoisingEnd: Float32 {
    let o = _accessor.offset(VTOFFSET.denoisingEnd.v)
    return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o)
  }
  public var triggerWord: String? {
    let o = _accessor.offset(VTOFFSET.triggerWord.v)
    return o == 0 ? nil : _accessor.string(at: o)
  }
  public var triggerWordSegmentArray: [UInt8]? {
    return _accessor.getVector(at: VTOFFSET.triggerWord.v)
  }
  public var autoFillPrompt: String? {
    let o = _accessor.offset(VTOFFSET.autoFillPrompt.v)
    return o == 0 ? nil : _accessor.string(at: o)
  }
  public var autoFillPromptSegmentArray: [UInt8]? {
    return _accessor.getVector(at: VTOFFSET.autoFillPrompt.v)
  }
  public var autoCaptioning: Bool {
    let o = _accessor.offset(VTOFFSET.autoCaptioning.v)
    return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o)
  }
  public var cotrainCustomEmbedding: Bool {
    let o = _accessor.offset(VTOFFSET.cotrainCustomEmbedding.v)
    return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o)
  }
  public var customEmbeddingLearningRate: Float32 {
    let o = _accessor.offset(VTOFFSET.customEmbeddingLearningRate.v)
    return o == 0 ? 0.05 : _accessor.readBuffer(of: Float32.self, at: o)
  }
  public var customEmbeddingLength: UInt32 {
    let o = _accessor.offset(VTOFFSET.customEmbeddingLength.v)
    return o == 0 ? 4 : _accessor.readBuffer(of: UInt32.self, at: o)
  }
  public var stopEmbeddingTrainingAtStep: UInt32 {
    let o = _accessor.offset(VTOFFSET.stopEmbeddingTrainingAtStep.v)
    return o == 0 ? 500 : _accessor.readBuffer(of: UInt32.self, at: o)
  }
  public var hasTrainableLayers: Bool {
    let o = _accessor.offset(VTOFFSET.trainableLayers.v)
    return o == 0 ? false : true
  }
  public var trainableLayersCount: Int32 {
    let o = _accessor.offset(VTOFFSET.trainableLayers.v)
    return o == 0 ? 0 : _accessor.vector(count: o)
  }
  public func trainableLayers(at index: Int32) -> zzz_DflatGen_LoRATrainableLayer? {
    let o = _accessor.offset(VTOFFSET.trainableLayers.v)
    return o == 0
      ? zzz_DflatGen_LoRATrainableLayer.latentsembedder
      : zzz_DflatGen_LoRATrainableLayer(
        rawValue: _accessor.directRead(of: Int8.self, offset: _accessor.vector(at: o) + index * 1))
  }
  public var hasLayerIndices: Bool {
    let o = _accessor.offset(VTOFFSET.layerIndices.v)
    return o == 0 ? false : true
  }
  public var layerIndicesCount: Int32 {
    let o = _accessor.offset(VTOFFSET.layerIndices.v)
    return o == 0 ? 0 : _accessor.vector(count: o)
  }
  public func layerIndices(at index: Int32) -> UInt32 {
    let o = _accessor.offset(VTOFFSET.layerIndices.v)
    return o == 0
      ? 0 : _accessor.directRead(of: UInt32.self, offset: _accessor.vector(at: o) + index * 4)
  }
  public var layerIndices: [UInt32] {
    return _accessor.getVector(at: VTOFFSET.layerIndices.v) ?? []
  }
  public var shift: Float32 {
    let o = _accessor.offset(VTOFFSET.shift.v)
    return o == 0 ? 1.0 : _accessor.readBuffer(of: Float32.self, at: o)
  }
  public var resolutionDependentShift: Bool {
    let o = _accessor.offset(VTOFFSET.resolutionDependentShift.v)
    return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o)
  }
  public var guidanceEmbedLowerBound: Float32 {
    let o = _accessor.offset(VTOFFSET.guidanceEmbedLowerBound.v)
    return o == 0 ? 3.0 : _accessor.readBuffer(of: Float32.self, at: o)
  }
  public var guidanceEmbedUpperBound: Float32 {
    let o = _accessor.offset(VTOFFSET.guidanceEmbedUpperBound.v)
    return o == 0 ? 4.0 : _accessor.readBuffer(of: Float32.self, at: o)
  }
  public var unetLearningRateLowerBound: Float32 {
    let o = _accessor.offset(VTOFFSET.unetLearningRateLowerBound.v)
    return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o)
  }
  public var stepsBetweenRestarts: UInt32 {
    let o = _accessor.offset(VTOFFSET.stepsBetweenRestarts.v)
    return o == 0 ? 200 : _accessor.readBuffer(of: UInt32.self, at: o)
  }
  public var captionDropoutRate: Float32 {
    let o = _accessor.offset(VTOFFSET.captionDropoutRate.v)
    return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o)
  }
  public var orthonormalLoraDown: Bool {
    let o = _accessor.offset(VTOFFSET.orthonormalLoraDown.v)
    return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o)
  }
  public var maxTextLength: UInt32 {
    let o = _accessor.offset(VTOFFSET.maxTextLength.v)
    return o == 0 ? 512 : _accessor.readBuffer(of: UInt32.self, at: o)
  }
  public var useImageAspectRatio: Bool {
    let o = _accessor.offset(VTOFFSET.useImageAspectRatio.v)
    return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o)
  }
  public var hasAdditionalScales: Bool {
    let o = _accessor.offset(VTOFFSET.additionalScales.v)
    return o == 0 ? false : true
  }
  public var additionalScalesCount: Int32 {
    let o = _accessor.offset(VTOFFSET.additionalScales.v)
    return o == 0 ? 0 : _accessor.vector(count: o)
  }
  public func additionalScales(at index: Int32) -> UInt16 {
    let o = _accessor.offset(VTOFFSET.additionalScales.v)
    return o == 0
      ? 0 : _accessor.directRead(of: UInt16.self, offset: _accessor.vector(at: o) + index * 2)
  }
  public var additionalScales: [UInt16] {
    return _accessor.getVector(at: VTOFFSET.additionalScales.v) ?? []
  }
  public var powerEmaLowerBound: Float32 {
    let o = _accessor.offset(VTOFFSET.powerEmaLowerBound.v)
    return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o)
  }
  public var powerEmaUpperBound: Float32 {
    let o = _accessor.offset(VTOFFSET.powerEmaUpperBound.v)
    return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o)
  }
  public static func startLoRATrainingConfiguration(_ fbb: inout FlatBufferBuilder) -> UOffset {
    fbb.startTable(with: 41)
  }
  public static func add(id: Int64, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: id, def: 0, at: VTOFFSET.id.p)
  }
  public static func add(name: Offset, _ fbb: inout FlatBufferBuilder) {
    fbb.add(offset: name, at: VTOFFSET.name.p)
  }
  public static func add(startWidth: UInt16, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: startWidth, def: 0, at: VTOFFSET.startWidth.p)
  }
  public static func add(startHeight: UInt16, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: startHeight, def: 0, at: VTOFFSET.startHeight.p)
  }
  public static func add(seed: UInt32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: seed, def: 0, at: VTOFFSET.seed.p)
  }
  public static func add(trainingSteps: UInt32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: trainingSteps, def: 0, at: VTOFFSET.trainingSteps.p)
  }
  public static func add(baseModel: Offset, _ fbb: inout FlatBufferBuilder) {
    fbb.add(offset: baseModel, at: VTOFFSET.baseModel.p)
  }
  public static func add(networkDim: UInt16, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: networkDim, def: 0, at: VTOFFSET.networkDim.p)
  }
  public static func add(networkScale: Float32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: networkScale, def: 0.0, at: VTOFFSET.networkScale.p)
  }
  public static func add(unetLearningRate: Float32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: unetLearningRate, def: 0.0, at: VTOFFSET.unetLearningRate.p)
  }
  public static func add(saveEveryNSteps: UInt32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: saveEveryNSteps, def: 0, at: VTOFFSET.saveEveryNSteps.p)
  }
  public static func add(warmupSteps: UInt32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: warmupSteps, def: 0, at: VTOFFSET.warmupSteps.p)
  }
  public static func add(gradientAccumulationSteps: UInt32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: gradientAccumulationSteps, def: 0, at: VTOFFSET.gradientAccumulationSteps.p)
  }
  public static func add(cotrainTextModel: Bool, _ fbb: inout FlatBufferBuilder) {
    fbb.add(
      element: cotrainTextModel, def: false,
      at: VTOFFSET.cotrainTextModel.p)
  }
  public static func add(textModelLearningRate: Float32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: textModelLearningRate, def: 0.0, at: VTOFFSET.textModelLearningRate.p)
  }
  public static func add(clipSkip: UInt32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: clipSkip, def: 1, at: VTOFFSET.clipSkip.p)
  }
  public static func add(noiseOffset: Float32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: noiseOffset, def: 0.0, at: VTOFFSET.noiseOffset.p)
  }
  public static func add(denoisingStart: Float32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: denoisingStart, def: 0.0, at: VTOFFSET.denoisingStart.p)
  }
  public static func add(denoisingEnd: Float32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: denoisingEnd, def: 0.0, at: VTOFFSET.denoisingEnd.p)
  }
  public static func add(triggerWord: Offset, _ fbb: inout FlatBufferBuilder) {
    fbb.add(offset: triggerWord, at: VTOFFSET.triggerWord.p)
  }
  public static func add(autoFillPrompt: Offset, _ fbb: inout FlatBufferBuilder) {
    fbb.add(offset: autoFillPrompt, at: VTOFFSET.autoFillPrompt.p)
  }
  public static func add(autoCaptioning: Bool, _ fbb: inout FlatBufferBuilder) {
    fbb.add(
      element: autoCaptioning, def: false,
      at: VTOFFSET.autoCaptioning.p)
  }
  public static func add(cotrainCustomEmbedding: Bool, _ fbb: inout FlatBufferBuilder) {
    fbb.add(
      element: cotrainCustomEmbedding, def: false,
      at: VTOFFSET.cotrainCustomEmbedding.p)
  }
  public static func add(customEmbeddingLearningRate: Float32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(
      element: customEmbeddingLearningRate, def: 0.05, at: VTOFFSET.customEmbeddingLearningRate.p)
  }
  public static func add(customEmbeddingLength: UInt32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: customEmbeddingLength, def: 4, at: VTOFFSET.customEmbeddingLength.p)
  }
  public static func add(stopEmbeddingTrainingAtStep: UInt32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(
      element: stopEmbeddingTrainingAtStep, def: 500, at: VTOFFSET.stopEmbeddingTrainingAtStep.p)
  }
  public static func addVectorOf(trainableLayers: Offset, _ fbb: inout FlatBufferBuilder) {
    fbb.add(offset: trainableLayers, at: VTOFFSET.trainableLayers.p)
  }
  public static func addVectorOf(layerIndices: Offset, _ fbb: inout FlatBufferBuilder) {
    fbb.add(offset: layerIndices, at: VTOFFSET.layerIndices.p)
  }
  public static func add(shift: Float32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: shift, def: 1.0, at: VTOFFSET.shift.p)
  }
  public static func add(resolutionDependentShift: Bool, _ fbb: inout FlatBufferBuilder) {
    fbb.add(
      element: resolutionDependentShift, def: false,
      at: VTOFFSET.resolutionDependentShift.p)
  }
  public static func add(guidanceEmbedLowerBound: Float32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: guidanceEmbedLowerBound, def: 3.0, at: VTOFFSET.guidanceEmbedLowerBound.p)
  }
  public static func add(guidanceEmbedUpperBound: Float32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: guidanceEmbedUpperBound, def: 4.0, at: VTOFFSET.guidanceEmbedUpperBound.p)
  }
  public static func add(unetLearningRateLowerBound: Float32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(
      element: unetLearningRateLowerBound, def: 0.0, at: VTOFFSET.unetLearningRateLowerBound.p)
  }
  public static func add(stepsBetweenRestarts: UInt32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: stepsBetweenRestarts, def: 200, at: VTOFFSET.stepsBetweenRestarts.p)
  }
  public static func add(captionDropoutRate: Float32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: captionDropoutRate, def: 0.0, at: VTOFFSET.captionDropoutRate.p)
  }
  public static func add(orthonormalLoraDown: Bool, _ fbb: inout FlatBufferBuilder) {
    fbb.add(
      element: orthonormalLoraDown, def: false,
      at: VTOFFSET.orthonormalLoraDown.p)
  }
  public static func add(maxTextLength: UInt32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: maxTextLength, def: 512, at: VTOFFSET.maxTextLength.p)
  }
  public static func add(useImageAspectRatio: Bool, _ fbb: inout FlatBufferBuilder) {
    fbb.add(
      element: useImageAspectRatio, def: false,
      at: VTOFFSET.useImageAspectRatio.p)
  }
  public static func addVectorOf(additionalScales: Offset, _ fbb: inout FlatBufferBuilder) {
    fbb.add(offset: additionalScales, at: VTOFFSET.additionalScales.p)
  }
  public static func add(powerEmaLowerBound: Float32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: powerEmaLowerBound, def: 0.0, at: VTOFFSET.powerEmaLowerBound.p)
  }
  public static func add(powerEmaUpperBound: Float32, _ fbb: inout FlatBufferBuilder) {
    fbb.add(element: powerEmaUpperBound, def: 0.0, at: VTOFFSET.powerEmaUpperBound.p)
  }
  public static func endLoRATrainingConfiguration(_ fbb: inout FlatBufferBuilder, start: UOffset)
    -> Offset
  {
    let end = Offset(offset: fbb.endTable(at: start))
    return end
  }
  public static func createLoRATrainingConfiguration(
    _ fbb: inout FlatBufferBuilder,
    id: Int64 = 0,
    nameOffset name: Offset = Offset(),
    startWidth: UInt16 = 0,
    startHeight: UInt16 = 0,
    seed: UInt32 = 0,
    trainingSteps: UInt32 = 0,
    baseModelOffset baseModel: Offset = Offset(),
    networkDim: UInt16 = 0,
    networkScale: Float32 = 0.0,
    unetLearningRate: Float32 = 0.0,
    saveEveryNSteps: UInt32 = 0,
    warmupSteps: UInt32 = 0,
    gradientAccumulationSteps: UInt32 = 0,
    cotrainTextModel: Bool = false,
    textModelLearningRate: Float32 = 0.0,
    clipSkip: UInt32 = 1,
    noiseOffset: Float32 = 0.0,
    denoisingStart: Float32 = 0.0,
    denoisingEnd: Float32 = 0.0,
    triggerWordOffset triggerWord: Offset = Offset(),
    autoFillPromptOffset autoFillPrompt: Offset = Offset(),
    autoCaptioning: Bool = false,
    cotrainCustomEmbedding: Bool = false,
    customEmbeddingLearningRate: Float32 = 0.05,
    customEmbeddingLength: UInt32 = 4,
    stopEmbeddingTrainingAtStep: UInt32 = 500,
    trainableLayersVectorOffset trainableLayers: Offset = Offset(),
    layerIndicesVectorOffset layerIndices: Offset = Offset(),
    shift: Float32 = 1.0,
    resolutionDependentShift: Bool = false,
    guidanceEmbedLowerBound: Float32 = 3.0,
    guidanceEmbedUpperBound: Float32 = 4.0,
    unetLearningRateLowerBound: Float32 = 0.0,
    stepsBetweenRestarts: UInt32 = 200,
    captionDropoutRate: Float32 = 0.0,
    orthonormalLoraDown: Bool = false,
    maxTextLength: UInt32 = 512,
    useImageAspectRatio: Bool = false,
    additionalScalesVectorOffset additionalScales: Offset = Offset(),
    powerEmaLowerBound: Float32 = 0.0,
    powerEmaUpperBound: Float32 = 0.0
  ) -> Offset {
    let __start = zzz_DflatGen_LoRATrainingConfiguration.startLoRATrainingConfiguration(&fbb)
    zzz_DflatGen_LoRATrainingConfiguration.add(id: id, &fbb)
    zzz_DflatGen_LoRATrainingConfiguration.add(name: name, &fbb)
    zzz_DflatGen_LoRATrainingConfiguration.add(startWidth: startWidth, &fbb)
    zzz_DflatGen_LoRATrainingConfiguration.add(startHeight: startHeight, &fbb)
    zzz_DflatGen_LoRATrainingConfiguration.add(seed: seed, &fbb)
    zzz_DflatGen_LoRATrainingConfiguration.add(trainingSteps: trainingSteps, &fbb)
    zzz_DflatGen_LoRATrainingConfiguration.add(baseModel: baseModel, &fbb)
    zzz_DflatGen_LoRATrainingConfiguration.add(networkDim: networkDim, &fbb)
    zzz_DflatGen_LoRATrainingConfiguration.add(networkScale: networkScale, &fbb)
    zzz_DflatGen_LoRATrainingConfiguration.add(unetLearningRate: unetLearningRate, &fbb)
    zzz_DflatGen_LoRATrainingConfiguration.add(saveEveryNSteps: saveEveryNSteps, &fbb)
    zzz_DflatGen_LoRATrainingConfiguration.add(warmupSteps: warmupSteps, &fbb)
    zzz_DflatGen_LoRATrainingConfiguration.add(
      gradientAccumulationSteps: gradientAccumulationSteps, &fbb)
    zzz_DflatGen_LoRATrainingConfiguration.add(cotrainTextModel: cotrainTextModel, &fbb)
    zzz_DflatGen_LoRATrainingConfiguration.add(textModelLearningRate: textModelLearningRate, &fbb)
    zzz_DflatGen_LoRATrainingConfiguration.add(clipSkip: clipSkip, &fbb)
    zzz_DflatGen_LoRATrainingConfiguration.add(noiseOffset: noiseOffset, &fbb)
    zzz_DflatGen_LoRATrainingConfiguration.add(denoisingStart: denoisingStart, &fbb)
    zzz_DflatGen_LoRATrainingConfiguration.add(denoisingEnd: denoisingEnd, &fbb)
    zzz_DflatGen_LoRATrainingConfiguration.add(triggerWord: triggerWord, &fbb)
    zzz_DflatGen_LoRATrainingConfiguration.add(autoFillPrompt: autoFillPrompt, &fbb)
    zzz_DflatGen_LoRATrainingConfiguration.add(autoCaptioning: autoCaptioning, &fbb)
    zzz_DflatGen_LoRATrainingConfiguration.add(cotrainCustomEmbedding: cotrainCustomEmbedding, &fbb)
    zzz_DflatGen_LoRATrainingConfiguration.add(
      customEmbeddingLearningRate: customEmbeddingLearningRate, &fbb)
    zzz_DflatGen_LoRATrainingConfiguration.add(customEmbeddingLength: customEmbeddingLength, &fbb)
    zzz_DflatGen_LoRATrainingConfiguration.add(
      stopEmbeddingTrainingAtStep: stopEmbeddingTrainingAtStep, &fbb)
    zzz_DflatGen_LoRATrainingConfiguration.addVectorOf(trainableLayers: trainableLayers, &fbb)
    zzz_DflatGen_LoRATrainingConfiguration.addVectorOf(layerIndices: layerIndices, &fbb)
    zzz_DflatGen_LoRATrainingConfiguration.add(shift: shift, &fbb)
    zzz_DflatGen_LoRATrainingConfiguration.add(
      resolutionDependentShift: resolutionDependentShift, &fbb)
    zzz_DflatGen_LoRATrainingConfiguration.add(
      guidanceEmbedLowerBound: guidanceEmbedLowerBound, &fbb)
    zzz_DflatGen_LoRATrainingConfiguration.add(
      guidanceEmbedUpperBound: guidanceEmbedUpperBound, &fbb)
    zzz_DflatGen_LoRATrainingConfiguration.add(
      unetLearningRateLowerBound: unetLearningRateLowerBound, &fbb)
    zzz_DflatGen_LoRATrainingConfiguration.add(stepsBetweenRestarts: stepsBetweenRestarts, &fbb)
    zzz_DflatGen_LoRATrainingConfiguration.add(captionDropoutRate: captionDropoutRate, &fbb)
    zzz_DflatGen_LoRATrainingConfiguration.add(orthonormalLoraDown: orthonormalLoraDown, &fbb)
    zzz_DflatGen_LoRATrainingConfiguration.add(maxTextLength: maxTextLength, &fbb)
    zzz_DflatGen_LoRATrainingConfiguration.add(useImageAspectRatio: useImageAspectRatio, &fbb)
    zzz_DflatGen_LoRATrainingConfiguration.addVectorOf(additionalScales: additionalScales, &fbb)
    zzz_DflatGen_LoRATrainingConfiguration.add(powerEmaLowerBound: powerEmaLowerBound, &fbb)
    zzz_DflatGen_LoRATrainingConfiguration.add(powerEmaUpperBound: powerEmaUpperBound, &fbb)
    return zzz_DflatGen_LoRATrainingConfiguration.endLoRATrainingConfiguration(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws
  where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.id.p, fieldName: "id", required: false, type: Int64.self)
    try _v.visit(
      field: VTOFFSET.name.p, fieldName: "name", required: false, type: ForwardOffset<String>.self)
    try _v.visit(
      field: VTOFFSET.startWidth.p, fieldName: "startWidth", required: false, type: UInt16.self)
    try _v.visit(
      field: VTOFFSET.startHeight.p, fieldName: "startHeight", required: false, type: UInt16.self)
    try _v.visit(field: VTOFFSET.seed.p, fieldName: "seed", required: false, type: UInt32.self)
    try _v.visit(
      field: VTOFFSET.trainingSteps.p, fieldName: "trainingSteps", required: false,
      type: UInt32.self)
    try _v.visit(
      field: VTOFFSET.baseModel.p, fieldName: "baseModel", required: false,
      type: ForwardOffset<String>.self)
    try _v.visit(
      field: VTOFFSET.networkDim.p, fieldName: "networkDim", required: false, type: UInt16.self)
    try _v.visit(
      field: VTOFFSET.networkScale.p, fieldName: "networkScale", required: false, type: Float32.self
    )
    try _v.visit(
      field: VTOFFSET.unetLearningRate.p, fieldName: "unetLearningRate", required: false,
      type: Float32.self)
    try _v.visit(
      field: VTOFFSET.saveEveryNSteps.p, fieldName: "saveEveryNSteps", required: false,
      type: UInt32.self)
    try _v.visit(
      field: VTOFFSET.warmupSteps.p, fieldName: "warmupSteps", required: false, type: UInt32.self)
    try _v.visit(
      field: VTOFFSET.gradientAccumulationSteps.p, fieldName: "gradientAccumulationSteps",
      required: false, type: UInt32.self)
    try _v.visit(
      field: VTOFFSET.cotrainTextModel.p, fieldName: "cotrainTextModel", required: false,
      type: Bool.self)
    try _v.visit(
      field: VTOFFSET.textModelLearningRate.p, fieldName: "textModelLearningRate", required: false,
      type: Float32.self)
    try _v.visit(
      field: VTOFFSET.clipSkip.p, fieldName: "clipSkip", required: false, type: UInt32.self)
    try _v.visit(
      field: VTOFFSET.noiseOffset.p, fieldName: "noiseOffset", required: false, type: Float32.self)
    try _v.visit(
      field: VTOFFSET.denoisingStart.p, fieldName: "denoisingStart", required: false,
      type: Float32.self)
    try _v.visit(
      field: VTOFFSET.denoisingEnd.p, fieldName: "denoisingEnd", required: false, type: Float32.self
    )
    try _v.visit(
      field: VTOFFSET.triggerWord.p, fieldName: "triggerWord", required: false,
      type: ForwardOffset<String>.self)
    try _v.visit(
      field: VTOFFSET.autoFillPrompt.p, fieldName: "autoFillPrompt", required: false,
      type: ForwardOffset<String>.self)
    try _v.visit(
      field: VTOFFSET.autoCaptioning.p, fieldName: "autoCaptioning", required: false,
      type: Bool.self)
    try _v.visit(
      field: VTOFFSET.cotrainCustomEmbedding.p, fieldName: "cotrainCustomEmbedding",
      required: false, type: Bool.self)
    try _v.visit(
      field: VTOFFSET.customEmbeddingLearningRate.p, fieldName: "customEmbeddingLearningRate",
      required: false, type: Float32.self)
    try _v.visit(
      field: VTOFFSET.customEmbeddingLength.p, fieldName: "customEmbeddingLength", required: false,
      type: UInt32.self)
    try _v.visit(
      field: VTOFFSET.stopEmbeddingTrainingAtStep.p, fieldName: "stopEmbeddingTrainingAtStep",
      required: false, type: UInt32.self)
    try _v.visit(
      field: VTOFFSET.trainableLayers.p, fieldName: "trainableLayers", required: false,
      type: ForwardOffset<Vector<zzz_DflatGen_LoRATrainableLayer, zzz_DflatGen_LoRATrainableLayer>>
        .self)
    try _v.visit(
      field: VTOFFSET.layerIndices.p, fieldName: "layerIndices", required: false,
      type: ForwardOffset<Vector<UInt32, UInt32>>.self)
    try _v.visit(field: VTOFFSET.shift.p, fieldName: "shift", required: false, type: Float32.self)
    try _v.visit(
      field: VTOFFSET.resolutionDependentShift.p, fieldName: "resolutionDependentShift",
      required: false, type: Bool.self)
    try _v.visit(
      field: VTOFFSET.guidanceEmbedLowerBound.p, fieldName: "guidanceEmbedLowerBound",
      required: false, type: Float32.self)
    try _v.visit(
      field: VTOFFSET.guidanceEmbedUpperBound.p, fieldName: "guidanceEmbedUpperBound",
      required: false, type: Float32.self)
    try _v.visit(
      field: VTOFFSET.unetLearningRateLowerBound.p, fieldName: "unetLearningRateLowerBound",
      required: false, type: Float32.self)
    try _v.visit(
      field: VTOFFSET.stepsBetweenRestarts.p, fieldName: "stepsBetweenRestarts", required: false,
      type: UInt32.self)
    try _v.visit(
      field: VTOFFSET.captionDropoutRate.p, fieldName: "captionDropoutRate", required: false,
      type: Float32.self)
    try _v.visit(
      field: VTOFFSET.orthonormalLoraDown.p, fieldName: "orthonormalLoraDown", required: false,
      type: Bool.self)
    try _v.visit(
      field: VTOFFSET.maxTextLength.p, fieldName: "maxTextLength", required: false,
      type: UInt32.self)
    try _v.visit(
      field: VTOFFSET.useImageAspectRatio.p, fieldName: "useImageAspectRatio", required: false,
      type: Bool.self)
    try _v.visit(
      field: VTOFFSET.additionalScales.p, fieldName: "additionalScales", required: false,
      type: ForwardOffset<Vector<UInt16, UInt16>>.self)
    try _v.visit(
      field: VTOFFSET.powerEmaLowerBound.p, fieldName: "powerEmaLowerBound", required: false,
      type: Float32.self)
    try _v.visit(
      field: VTOFFSET.powerEmaUpperBound.p, fieldName: "powerEmaUpperBound", required: false,
      type: Float32.self)
    _v.finish()
  }
}
